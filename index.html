<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>TiltSphere - Ultimate Ball Challenge</title>
    <style>
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
            overflow: hidden;
        }

        body {
            background: linear-gradient(135deg, #0f0f23, #1a1a2e, #16213e, #0f3460);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            font-family: 'Arial', sans-serif;
            color: #ffffff;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Header styles */
        .header {
            text-align: center;
            margin-bottom: 10px;
            z-index: 50;
        }

        .title {
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(99, 179, 237, 0.8);
            margin-bottom: 5px;
            background: linear-gradient(45deg, #63b3ed, #4fd1c7, #68d391);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stats {
            display: flex;
            gap: 15px;
            font-size: 14px;
            margin-bottom: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .stat-item {
            padding: 3px 8px;
            background: rgba(99, 179, 237, 0.1);
            border-radius: 10px;
            border: 1px solid rgba(99, 179, 237, 0.3);
        }

        .progress-meter {
            width: 200px;
            height: 12px;
            background: #333;
            border: 1px solid #63b3ed;
            margin: 10px auto;
            border-radius: 6px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #68d391, #4fd1c7, #63b3ed);
            width: 0%;
            transition: width 0.5s ease;
        }

        /* Difficulty badges */
        .difficulty-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            margin-left: 8px;
        }

        .difficulty-easy { background: #68d391; color: #000; }
        .difficulty-medium { background: #f6ad55; color: #000; }
        .difficulty-hard { background: #f56565; color: #fff; }
        .difficulty-expert { background: #9f7aea; color: #fff; }
        .difficulty-legendary { background: #ffd700; color: #000; }
        .difficulty-master { background: #e53e3e; color: #fff; }
        .difficulty-grandmaster { background: #1a365d; color: #fff; }
        .difficulty-ultimate { background: #000000; color: #ffd700; }
        /* Game container styles */
        .game-container {
            position: relative;
            width: 350px;
            height: 350px;
            background: radial-gradient(circle at center, #2d3748, #1a202c);
            border: 3px solid #63b3ed;
            border-radius: 20px;
            box-shadow: 
                0 0 30px rgba(99, 179, 237, 0.4),
                inset 0 0 30px rgba(99, 179, 237, 0.1);
            overflow: hidden;
        }

        /* Ball styles */
        .ball {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle at 30% 30%, #ffffff, #f56565, #e53e3e);
            border-radius: 50%;
            box-shadow: 
                0 0 20px rgba(245, 101, 101, 0.8),
                inset -3px -3px 8px rgba(0, 0, 0, 0.4),
                inset 2px 2px 4px rgba(255, 255, 255, 0.3);
            transition: none;
            z-index: 10;
            left: 165px;
            top: 165px;
        }

        /* Ball trail effects */
        .ball-trail {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(245, 101, 101, 0.6), transparent);
            pointer-events: none;
            z-index: 5;
            opacity: 0.7;
        }

        /* Target funnel styles */
        .funnel {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle at center, #38a169, #48bb78, #68d391);
            box-shadow: 
                0 0 25px rgba(104, 211, 145, 0.8),
                inset 0 0 15px rgba(0, 0, 0, 0.5);
            border: 2px solid #68d391;
            animation: funnelPulse 2s ease-in-out infinite;
            left: 250px;
            top: 250px;
        }

        @keyframes funnelPulse {
            0%, 100% { 
                box-shadow: 0 0 25px rgba(104, 211, 145, 0.8), inset 0 0 15px rgba(0, 0, 0, 0.5); 
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 40px rgba(104, 211, 145, 1), inset 0 0 15px rgba(0, 0, 0, 0.5); 
                transform: scale(1.05);
            }
        }

        /* Obstacle styles */
        .obstacle {
            position: absolute;
            background: linear-gradient(45deg, #744210, #975a16);
            border: 1px solid #d69e2e;
            box-shadow: 0 0 15px rgba(214, 158, 46, 0.4);
        }

        .moving-obstacle {
            background: linear-gradient(45deg, #553c9a, #6b46c1);
            border: 1px solid #9f7aea;
            box-shadow: 0 0 15px rgba(159, 122, 234, 0.4);
        }

        /* Particle effects */
        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 15;
        }

        /* Control styles */
        .controls {
            text-align: center;
            margin-top: 15px;
            font-size: 12px;
            max-width: 350px;
            z-index: 50;
        }

        .start-button, .menu-button {
            background: linear-gradient(45deg, #63b3ed, #4fd1c7);
            border: none;
            color: white;
            padding: 12px 24px;
            font-family: inherit;
            cursor: pointer;
            margin: 8px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(99, 179, 237, 0.3);
            transition: all 0.3s ease;
        }

        .start-button:hover, .menu-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(99, 179, 237, 0.4);
        }

        .menu-button {
            font-size: 12px;
            padding: 8px 16px;
            background: linear-gradient(45deg, #4a5568, #63b3ed);
        }

        .menu-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Animation utilities */
        .pulse {
            animation: pulse 0.5s ease;
        }

        .shake {
            animation: shake 0.3s ease;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); box-shadow: 0 0 40px rgba(99, 179, 237, 0.8); }
            100% { transform: scale(1); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* Moving obstacle animations */
        @keyframes movingObstacle {
            0% { transform: translateX(0); }
            50% { transform: translateX(80px); }
            100% { transform: translateX(0); }
        }

        .obstacle.moving {
            animation: movingObstacle 4s ease-in-out infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .obstacle.rotating {
            animation: rotate 6s linear infinite;
        }

        /* Particle explosion effects */
        @keyframes particleExplosion {
            0% {
                opacity: 1;
                transform: scale(1) translateX(0) translateY(0);
            }
            100% {
                opacity: 0;
                transform: scale(0.2) translateX(var(--dx)) translateY(var(--dy));
            }
        }

        .particle-explosion {
            animation: particleExplosion 0.8s ease-out forwards;
        }

        /* Save indicator */
        .save-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(104, 211, 145, 0.2);
            border: 1px solid #68d391;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 10px;
            color: #68d391;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .save-indicator.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">TILTSPHERE</div>
        <div class="stats">
            <div class="stat-item">Level: <span id="level">1</span><span id="difficultyBadge" class="difficulty-badge difficulty-easy">EASY</span></div>
            <div class="stat-item">Score: <span id="score">0</span></div>
            <div class="stat-item">Best: <span id="bestScore">0</span></div>
        </div>
        <div class="progress-meter">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div style="font-size: 10px;">Progress: <span id="progressLevel">0%</span> â€¢ <span id="achievementCount">0</span> achievements</div>
    </div>

    <div class="game-container" id="gameContainer">
        <div class="ball" id="ball"></div>
        <div class="funnel" id="funnel"></div>
        <div class="save-indicator" id="saveIndicator">Progress Saved!</div>
    </div>

    <div class="controls">
        <button class="start-button" id="startButton">START GAME</button>
       <div class="menu-buttons" id="menuButtons" style="display: none;">
    <button class="menu-button" onclick="game.pauseGame()">Pause</button>
    <button class="menu-button" onclick="game.saveGame()">Save</button>
    <button class="menu-button" onclick="game.showSettings()">Settings</button>
    <button class="menu-button" onclick="game.resetProgress()">Reset</button>
</div>
        
        <div>Tilt your device to guide the ball into the target</div>
        <div style="margin-top: 5px; font-size: 10px;" id="saveStatus"></div>
    </div>

    <!-- Settings Modal -->
<div id="settingsModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 100; align-items: center; justify-content: center;">        <div style="background: linear-gradient(135deg, #1a202c, #2d3748); border: 2px solid #63b3ed; border-radius: 15px; padding: 20px; width: 90%; max-width: 300px; color: white;">
            <h3 style="text-align: center; margin-bottom: 20px; color: #63b3ed;">Settings</h3>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">Sensitivity: <span id="sensitivityValue">50</span>%</label>
                <input type="range" id="sensitivitySlider" min="10" max="100" value="50" style="width: 100%;">
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="soundToggle" checked>
                    <span>Sound Effects</span>
                </label>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="hapticToggle" checked>
                    <span>Haptic Feedback</span>
                </label>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="trailToggle" checked>
                    <span>Ball Trail</span>
                </label>
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button onclick="game.saveSettings()" style="background: #68d391; color: black; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer;">Save</button>
                <button onclick="game.closeSettings()" style="background: #f56565; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer;">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        class TiltBallGame {
            constructor() {
                // DOM elements
                this.ball = document.getElementById('ball');
                this.funnel = document.getElementById('funnel');
                this.gameContainer = document.getElementById('gameContainer');
                this.startButton = document.getElementById('startButton');
                
                // Ball physics
                this.ballX = 165;
                this.ballY = 165;
                this.ballVelX = 0;
                this.ballVelY = 0;
                this.friction = 0.95;
                this.sensitivity = 0.5;
                
                // Game state
                this.level = 1;
                this.score = 0;
                this.bestScore = parseInt(localStorage.getItem('tiltSphereBest') || '0');
                this.gameRunning = false;
                this.gamePaused = false;
                this.obstacles = [];
                this.particles = [];
                this.ballTrail = [];
                this.achievements = JSON.parse(localStorage.getItem('tiltSphereAchievements') || '[]');
                
                // CRITICAL: Race condition protection
                this.levelCompleting = false;
                
                // Game constants
                this.containerWidth = 350;
                this.containerHeight = 350;
                this.ballSize = 20;
                
                // Settings
                this.settings = {
                    sound: true,
                    haptic: true,
                    trail: true,
                    sensitivity: 50
                };
                
                // Load settings
                const savedSettings = localStorage.getItem('tiltSphereSettings');
                if (savedSettings) {
                    this.settings = { ...this.settings, ...JSON.parse(savedSettings) };
                }
                
                // Generate all 250 levels with proper funnel sizing
                this.levelConfigs = this.generateLevelConfigs();
                
                // Initialize
                this.loadGame();
                this.setupLevel();
                this.updateUI();
                
                // Event listeners
                this.startButton.addEventListener('click', () => this.requestPermission());
            }
            
            generateLevelConfigs() {
                const configs = [];
                
                // Levels 1-20: Learning (Easy) - Funnel 60px down to 35px minimum
                // Levels 1-20: Learning (Easy) - Enhanced with better obstacle distribution
// Levels 1-20: Learning (Easy) - Enhanced with better obstacle distribution
for (let i = 1; i <= 20; i++) {
    configs.push({
        funnelSize: Math.max(60 - i * 2, 35),
        obstacles: Math.min(2 + Math.floor(i / 3), 6), // Start with 2 obstacles, increase more gradually
        timeLimit: 0,
        movingObstacles: 0,
        ballSpeed: 1 + (i * 0.02),
        difficulty: 'easy',
        specialMechanic: null
    });
}
                
                // Levels 21-40: Building Skills (Medium) - Funnel 35px down to 30px minimum
                for (let i = 21; i <= 40; i++) {
                    configs.push({
                        funnelSize: Math.max(35 - (i - 20) * 0.25, 30),
                        obstacles: Math.min(2 + Math.floor((i - 20) / 3), 6),
                        timeLimit: 0,
                        movingObstacles: Math.min(Math.floor((i - 25) / 3), 2),
                        ballSpeed: 1.2 + ((i - 20) * 0.03),
                        difficulty: 'medium',
                        specialMechanic: i % 8 === 0 ? 'rotating' : null
                    });
                }
                
                // Levels 41-60: Advanced (Hard) - Funnel fixed at 30px minimum
                for (let i = 41; i <= 60; i++) {
                    configs.push({
                        funnelSize: 30, // Fixed minimum for playability
                        obstacles: Math.min(4 + Math.floor((i - 40) / 2), 10),
                        timeLimit: 0,
                        movingObstacles: Math.min(Math.floor((i - 40) / 3), 4),
                        ballSpeed: 1.4 + ((i - 40) * 0.04),
                        difficulty: 'hard',
                        specialMechanic: ['rotating', 'bouncy'][Math.floor((i - 40) / 10) % 2]
                    });
                }
                
                // Levels 61-80: Expert - 30px funnel, more obstacles
                for (let i = 61; i <= 80; i++) {
                    configs.push({
                        funnelSize: 30,
                        obstacles: Math.min(6 + Math.floor((i - 60) / 2), 15),
                        timeLimit: 0,
                        movingObstacles: Math.min(3 + Math.floor((i - 60) / 3), 6),
                        ballSpeed: 1.6 + ((i - 60) * 0.05),
                        difficulty: 'expert',
                        specialMechanic: ['maze', 'spiral'][Math.floor((i - 60) / 10) % 2]
                    });
                }
                
                // Levels 81-100: Legendary
                for (let i = 81; i <= 100; i++) {
                    configs.push({
                        funnelSize: 30,
                        obstacles: Math.min(10 + Math.floor((i - 80) / 2), 20),
                        timeLimit: 0,
                        movingObstacles: Math.min(4 + Math.floor((i - 80) / 2), 8),
                        ballSpeed: 1.8 + ((i - 80) * 0.06),
                        difficulty: 'legendary',
                        specialMechanic: ['ultimate', 'chaos'][Math.floor((i - 80) / 10) % 2]
                    });
                }
                
                // Continue pattern for remaining levels up to 250
                // Levels 101-250: Keeping 30px minimum funnel, increasing obstacles
                for (let i = 101; i <= 250; i++) {
                    const tier = Math.floor((i - 101) / 50);
                    const difficultyNames = ['master', 'grandmaster', 'ultimate'];
                    
                    configs.push({
                        funnelSize: 30, // Always playable
                        obstacles: Math.min(12 + Math.floor((i - 100) / 5), 35),
                        timeLimit: 0,
                        movingObstacles: Math.min(5 + Math.floor((i - 100) / 10), 15),
                        ballSpeed: 2.0 + ((i - 100) * 0.02),
                        difficulty: difficultyNames[Math.min(tier, 2)],
                        specialMechanic: ['master_challenge', 'ultimate_precision', 'chaos_mode'][tier % 3]
                    });
                }
                
                return configs;
            }
            setupLevel() {
                // Clear any existing obstacles and particles
                this.clearObstacles();
                this.clearParticles();
                this.ballTrail = [];
                
                const config = this.getCurrentConfig();
                
                // Setup funnel with enforced minimum size
                const funnelSize = Math.max(config.funnelSize, 30); // Never smaller than 30px
                this.funnel.style.width = funnelSize + 'px';
                this.funnel.style.height = funnelSize + 'px';
                
                // Strategic funnel positioning - ensure 120px minimum distance from ball center
                // Strategic funnel positioning - ensure 120px minimum distance from ball center
const minDistanceFromBall = 120;
const margin = Math.max(funnelSize + 20, 30);
let attempts = 0;
let validFunnelPosition = false;

while (!validFunnelPosition && attempts < 50) {
    this.funnelX = margin + Math.random() * (this.containerWidth - 2 * margin - funnelSize);
    this.funnelY = margin + Math.random() * (this.containerHeight - 2 * margin - funnelSize);
    
    const funnelCenterX = this.funnelX + funnelSize / 2;
    const funnelCenterY = this.funnelY + funnelSize / 2;
    const distanceFromBall = Math.sqrt((funnelCenterX - 165) ** 2 + (funnelCenterY - 165) ** 2);
    
    if (distanceFromBall >= minDistanceFromBall) {
        validFunnelPosition = true;
    }
    attempts++;
}

// Improved fallback - multiple fallback positions instead of always the same spot
if (!validFunnelPosition) {
    const fallbackPositions = [
        { x: this.containerWidth - funnelSize - 40, y: 40 }, // top-right
        { x: 40, y: this.containerHeight - funnelSize - 40 }, // bottom-left
        { x: this.containerWidth - funnelSize - 40, y: this.containerHeight - funnelSize - 40 }, // bottom-right
        { x: 40, y: 40 } // top-left
    ];
    
    const randomFallback = fallbackPositions[Math.floor(Math.random() * fallbackPositions.length)];
    this.funnelX = randomFallback.x;
    this.funnelY = randomFallback.y;
}
                this.funnel.style.left = this.funnelX + 'px';
                this.funnel.style.top = this.funnelY + 'px';
                
                // Add obstacles with special mechanics
                this.addObstacles(config.obstacles, config.movingObstacles, config.specialMechanic);
                
                // Reset ball to center
                this.ballX = 165;
                this.ballY = 165;
                this.ballVelX = 0;
                this.ballVelY = 0;
                
                this.updateDifficultyBadge(config.difficulty);
            }
            
            getCurrentConfig() {
                return this.levelConfigs[Math.min(this.level - 1, this.levelConfigs.length - 1)];
            }
            
            addObstacles(numStatic, numMoving, specialMechanic) {
                for (let i = 0; i < numStatic; i++) {
                    this.createObstacle(false, specialMechanic);
                }
                
                for (let i = 0; i < numMoving; i++) {
                    this.createObstacle(true, specialMechanic);
                }
            }
            
            createObstacle(isMoving = false, specialMechanic = null) {
    const obstacle = document.createElement('div');
    obstacle.className = 'obstacle';
    
    const size = 20 + Math.random() * 15; // 20-35px obstacles
    obstacle.style.width = size + 'px';
    obstacle.style.height = size + 'px';
    
    // Strategic positioning based on ball-to-funnel path
    let x, y;
    let attempts = 0;
    let validPosition = false;
    
    while (!validPosition && attempts < 100) {
        // Calculate the direct path from ball (165, 165) to funnel center
        const ballX = 165;
        const ballY = 165;
        const funnelCenterX = this.funnelX + this.getCurrentConfig().funnelSize / 2;
        const funnelCenterY = this.funnelY + this.getCurrentConfig().funnelSize / 2;
        
        // Create obstacles along or near the path between ball and funnel
        const pathProgress = Math.random(); // 0 to 1 along the path
        const pathVariation = (Math.random() - 0.5) * 120; // Up to 60px deviation from direct path
        
        // Calculate position along the path with some variation
        const directX = ballX + (funnelCenterX - ballX) * pathProgress;
        const directY = ballY + (funnelCenterY - ballY) * pathProgress;
        
        // Add perpendicular variation to create interesting paths
        const pathAngle = Math.atan2(funnelCenterY - ballY, funnelCenterX - ballX);
        const perpAngle = pathAngle + Math.PI / 2;
        
        x = directX + Math.cos(perpAngle) * pathVariation;
        y = directY + Math.sin(perpAngle) * pathVariation;
        
        // Ensure obstacle stays within bounds
        x = Math.max(20, Math.min(x, this.containerWidth - size - 20));
        y = Math.max(20, Math.min(y, this.containerHeight - size - 20));
        
        // Check distance from ball spawn (must be at least 40px away)
        const distanceFromBall = Math.sqrt((x - ballX) ** 2 + (y - ballY) ** 2);
        
        // Check distance from funnel (must be at least 30px away from funnel edge)
        const distanceFromFunnel = Math.sqrt(
            (x - funnelCenterX) ** 2 + (y - funnelCenterY) ** 2
        ) - this.getCurrentConfig().funnelSize / 2;
        
        // Check distance from other obstacles (must be at least 25px apart)
        let tooCloseToOtherObstacles = false;
        this.obstacles.forEach(otherObstacle => {
            const otherRect = otherObstacle.element.getBoundingClientRect();
            const containerRect = this.gameContainer.getBoundingClientRect();
            const otherX = otherRect.left - containerRect.left;
            const otherY = otherRect.top - containerRect.top;
            
            const distance = Math.sqrt((x - otherX) ** 2 + (y - otherY) ** 2);
            if (distance < 25) {
                tooCloseToOtherObstacles = true;
            }
        });
        
        if (distanceFromBall >= 40 && 
            distanceFromFunnel >= 30 && 
            !tooCloseToOtherObstacles) {
            validPosition = true;
        }
        
        attempts++;
    }
    
    // If we can't find a strategic position, fall back to safer random placement
    if (!validPosition) {
        const margin = 30;
        x = margin + Math.random() * (this.containerWidth - 2 * margin - size);
        y = margin + Math.random() * (this.containerHeight - 2 * margin - size);
    }
    
    obstacle.style.left = x + 'px';
    obstacle.style.top = y + 'px';
    
    this.gameContainer.appendChild(obstacle);
    this.obstacles.push({ element: obstacle, x, y, width: size, height: size, isMoving });
}
            
            clearObstacles() {
                this.obstacles.forEach(obs => obs.element.remove());
                this.obstacles = [];
            }
            
            clearParticles() {
                this.particles.forEach(particle => particle.element.remove());
                this.particles = [];
            }
            
            updateDifficultyBadge(difficulty) {
                const badge = document.getElementById('difficultyBadge');
                badge.className = `difficulty-badge difficulty-${difficulty}`;
                badge.textContent = difficulty.toUpperCase();
            }
            
            updateUI() {
                document.getElementById('level').textContent = this.level;
                document.getElementById('score').textContent = this.score;
                document.getElementById('bestScore').textContent = this.bestScore;
                document.getElementById('achievementCount').textContent = this.achievements.length;
                
                const progress = Math.min((this.level / this.levelConfigs.length) * 100, 100);
                document.getElementById('progressLevel').textContent = Math.round(progress) + '%';
                document.getElementById('progressFill').style.width = progress + '%';
            }
            async requestPermission() {
                try {
                    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        if (permission === 'granted') {
                            this.startGame();
                        }
                    } else {
                        this.startGame();
                    }
                } catch (error) {
                    console.error('Permission request failed:', error);
                    this.startGame();
                }
            }
            
            startGame() {
                this.gameRunning = true;
                this.gamePaused = false;
                this.startButton.style.display = 'none';
                document.getElementById('menuButtons').style.display = 'flex';
                
                // Add device orientation and keyboard controls
                window.addEventListener('deviceorientation', (e) => this.handleOrientation(e));
                window.addEventListener('keydown', (e) => this.handleKeyboard(e));
                
                this.gameLoop();
            }
            
            handleOrientation(event) {
                if (!this.gameRunning || this.gamePaused) return;
                
                const gamma = event.gamma || 0;  // left/right tilt
                const beta = event.beta || 0;    // forward/back tilt
                
                const config = this.getCurrentConfig();
                const sensitivity = (this.settings.sensitivity / 100) * this.sensitivity * config.ballSpeed;
                
                this.ballVelX += gamma * sensitivity * 0.1;
                this.ballVelY += beta * sensitivity * 0.1;
            }
            
            handleKeyboard(event) {
                if (!this.gameRunning || this.gamePaused) return;
                
                const config = this.getCurrentConfig();
                const force = (this.settings.sensitivity / 100) * 0.5 * config.ballSpeed;
                
                switch(event.key) {
                    case 'ArrowLeft': this.ballVelX -= force; break;
                    case 'ArrowRight': this.ballVelX += force; break;
                    case 'ArrowUp': this.ballVelY -= force; break;
                    case 'ArrowDown': this.ballVelY += force; break;
                    case ' ': 
                        event.preventDefault();
                        if (this.gamePaused) this.resumeGame();
                        else this.pauseGame();
                        break;
                }
            }
            
            gameLoop() {
                if (!this.gameRunning || this.gamePaused) {
                    if (this.gameRunning) {
                        requestAnimationFrame(() => this.gameLoop());
                    }
                    return;
                }
                
                // Apply physics
                this.ballVelX *= this.friction;
                this.ballVelY *= this.friction;
                
                this.ballX += this.ballVelX;
                this.ballY += this.ballVelY;
                
                // Wall collisions with bounce
                if (this.ballX <= 0) {
                    this.ballX = 0;
                    this.ballVelX *= -0.7;
                    this.createParticles(this.ballX, this.ballY, '#ff6b6b');
                }
                if (this.ballX >= this.containerWidth - this.ballSize) {
                    this.ballX = this.containerWidth - this.ballSize;
                    this.ballVelX *= -0.7;
                    this.createParticles(this.ballX, this.ballY, '#ff6b6b');
                }
                if (this.ballY <= 0) {
                    this.ballY = 0;
                    this.ballVelY *= -0.7;
                    this.createParticles(this.ballY, this.ballY, '#ff6b6b');
                }
                if (this.ballY >= this.containerHeight - this.ballSize) {
                    this.ballY = this.containerHeight - this.ballSize;
                    this.ballVelY *= -0.7;
                    this.createParticles(this.ballX, this.ballY, '#ff6b6b');
                }
                
                // Update ball trail if enabled
                if (this.settings.trail) {
                    this.updateBallTrail();
                }
                
                // Update ball position
                this.ball.style.left = this.ballX + 'px';
                this.ball.style.top = this.ballY + 'px';
                
                // Check obstacle collisions
                this.checkObstacleCollision();
                
                // Check funnel collision (with race condition protection)
                this.checkFunnelCollision();
                
                requestAnimationFrame(() => this.gameLoop());
            }
            
            checkObstacleCollision() {
                this.obstacles.forEach(obs => {
                    const rect = obs.element.getBoundingClientRect();
                    const containerRect = this.gameContainer.getBoundingClientRect();
                    
                    const obsX = rect.left - containerRect.left;
                    const obsY = rect.top - containerRect.top;
                    
                    if (this.ballX < obsX + obs.width &&
                        this.ballX + this.ballSize > obsX &&
                        this.ballY < obsY + obs.height &&
                        this.ballY + this.ballSize > obsY) {
                        
                        // Bounce off obstacle
                        this.ballVelX *= -0.5;
                        this.ballVelY *= -0.5;
                        
                        this.createParticles(this.ballX + this.ballSize/2, this.ballY + this.ballSize/2, '#d69e2e');
                        this.gameContainer.classList.add('shake');
                        setTimeout(() => this.gameContainer.classList.remove('shake'), 300);
                        
                        // Push ball away from obstacle center
                        const centerX = obsX + obs.width / 2;
                        const centerY = obsY + obs.height / 2;
                        const ballCenterX = this.ballX + this.ballSize / 2;
                        const ballCenterY = this.ballY + this.ballSize / 2;
                        
                        const dx = ballCenterX - centerX;
                        const dy = ballCenterY - centerY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 0) {
                            this.ballVelX += (dx / distance) * 2;
                            this.ballVelY += (dy / distance) * 2;
                        }
                    }
                });
            }
            
            checkFunnelCollision() {
                // CRITICAL: Prevent race condition with levelCompleting flag
                if (this.levelCompleting) return;
                
                const config = this.getCurrentConfig();
                const funnelSize = Math.max(config.funnelSize, 30);
                const funnelCenterX = this.funnelX + funnelSize / 2;
                const funnelCenterY = this.funnelY + funnelSize / 2;
                const ballCenterX = this.ballX + this.ballSize / 2;
                const ballCenterY = this.ballY + this.ballSize / 2;
                
                const distance = Math.sqrt(
                    (ballCenterX - funnelCenterX) ** 2 + 
                    (ballCenterY - funnelCenterY) ** 2
                );
                
                if (distance < funnelSize / 2 - 5) {
                    this.levelComplete();
                }
            }
            levelComplete() {
                // CRITICAL: Prevent multiple calls during collision detection
                if (this.levelCompleting) return;
                this.levelCompleting = true;
                
                // Add visual feedback
                this.gameContainer.classList.add('pulse');
                setTimeout(() => this.gameContainer.classList.remove('pulse'), 500);
                
                // Calculate score
                const levelBonus = this.level * 100;
                const timeBonus = 0; // No time bonuses yet
                const totalBonus = levelBonus + timeBonus;
                
                this.score += totalBonus;
                
                // Update best score
                if (this.score > this.bestScore) {
                    this.bestScore = this.score;
                    localStorage.setItem('tiltSphereBest', this.bestScore.toString());
                }
                
                // Create celebration particles
                this.createParticles(this.ballX + this.ballSize/2, this.ballY + this.ballSize/2, '#68d391', 20);
                this.createParticles(this.ballX + this.ballSize/2, this.ballY + this.ballSize/2, '#ffd700', 12);
                
                // Advance to next level
                this.level++;
                
                // Check if game complete
                if (this.level > this.levelConfigs.length) {
                    this.endGame();
                    return;
                }
                
                // Auto-save progress
                this.saveGame();
                
                // Update UI
                this.updateUI();
                
                // Setup next level after brief delay
                setTimeout(() => {
                    this.setupLevel();
                    this.levelCompleting = false; // Reset flag after level setup
                }, 1000);
            }
            
            endGame() {
                this.gameRunning = false;
                this.levelCompleting = false;
                
                alert(`Congratulations! You completed all ${this.levelConfigs.length} levels!\nFinal Score: ${this.score}`);
                
                // Reset for replay
                this.level = 1;
                this.score = 0;
                this.startButton.style.display = 'block';
                this.startButton.textContent = 'PLAY AGAIN';
                document.getElementById('menuButtons').style.display = 'none';
                this.setupLevel();
                this.updateUI();
            }
            
            pauseGame() {
                if (!this.gameRunning) return;
                this.gamePaused = true;
                alert('Game Paused - Click OK to resume');
                this.gamePaused = false;
            }
            
            resumeGame() {
                this.gamePaused = false;
                // Reset ball velocity to prevent accumulated motion
                this.ballVelX = 0;
                this.ballVelY = 0;
            }
            
            resetProgress() {
                if (confirm('Are you sure you want to reset all progress? This cannot be undone.')) {
                    localStorage.removeItem('tiltSphereSave');
                    localStorage.removeItem('tiltSphereBest');
                    localStorage.removeItem('tiltSphereAchievements');
                    
                    this.level = 1;
                    this.score = 0;
                    this.bestScore = 0;
                    this.achievements = [];
                    this.gameRunning = false;
                    this.levelCompleting = false;
                    
                    this.startButton.style.display = 'block';
                    this.startButton.textContent = 'START GAME';
                    document.getElementById('menuButtons').style.display = 'none';
                    
                    this.setupLevel();
                    this.updateUI();
                    
                    document.getElementById('saveStatus').textContent = 'Progress reset';
                }
            }
            
            createParticles(x, y, color, count = 8) {
                // Prevent too many particles on slower devices
                if (this.particles.length > 50) return;
                
                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.background = color;
                    particle.style.left = x + 'px';
                    particle.style.top = y + 'px';
                    
                    const angle = (Math.PI * 2 * i) / count;
                    const velocity = 30 + Math.random() * 20;
                    const dx = Math.cos(angle) * velocity;
                    const dy = Math.sin(angle) * velocity;
                    
                    particle.style.setProperty('--dx', dx + 'px');
                    particle.style.setProperty('--dy', dy + 'px');
                    particle.classList.add('particle-explosion');
                    
                    this.gameContainer.appendChild(particle);
                    this.particles.push({ element: particle, life: 0.8 });
                    
                    setTimeout(() => {
                        particle.remove();
                        this.particles = this.particles.filter(p => p.element !== particle);
                    }, 800);
                }
            }
            
            updateBallTrail() {
                // Add new trail point
                this.ballTrail.push({
                    x: this.ballX + this.ballSize/2,
                    y: this.ballY + this.ballSize/2,
                    life: 1.0
                });
                
                // Keep trail short for performance
                if (this.ballTrail.length > 8) {
                    this.ballTrail.shift();
                }
                
                // Update existing trail elements
                const existingTrails = this.gameContainer.querySelectorAll('.ball-trail');
                existingTrails.forEach(trail => trail.remove());
                
                // Create new trail elements
                this.ballTrail.forEach((point, index) => {
                    const trail = document.createElement('div');
                    trail.className = 'ball-trail';
                    trail.style.left = (point.x - 7.5) + 'px';
                    trail.style.top = (point.y - 7.5) + 'px';
                    trail.style.opacity = (index / this.ballTrail.length) * 0.7;
                    trail.style.transform = `scale(${0.3 + (index / this.ballTrail.length) * 0.7})`;
                    this.gameContainer.appendChild(trail);
                });
            }
            saveGame() {
                const saveData = {
                    level: this.level,
                    score: this.score,
                    achievements: this.achievements,
                    timestamp: Date.now()
                };
                
                localStorage.setItem('tiltSphereSave', JSON.stringify(saveData));
                
                // Show save indicator
                const indicator = document.getElementById('saveIndicator');
                indicator.classList.add('show');
                setTimeout(() => indicator.classList.remove('show'), 2000);
                
                document.getElementById('saveStatus').textContent = `Last saved: ${new Date().toLocaleTimeString()}`;
            }
            
            loadGame() {
                const saveData = localStorage.getItem('tiltSphereSave');
                if (saveData) {
                    try {
                        const data = JSON.parse(saveData);
                        this.level = data.level || 1;
                        this.score = data.score || 0;
                        this.achievements = data.achievements || [];
                        
                        const saveTime = new Date(data.timestamp).toLocaleString();
                        document.getElementById('saveStatus').textContent = `Loaded save from: ${saveTime}`;
                        
                        // Note: setupLevel() and updateUI() are called by constructor
                    } catch (error) {
                        console.error('Failed to load save data:', error);
                    }
                }
            }
            
            checkAchievements() {
    const newAchievements = [];
    
    // First Win
    if (this.level === 2 && !this.achievements.includes('first_win')) {
        newAchievements.push('first_win');
        this.achievements.push('first_win');
    }
    
    // Level Milestones
    const milestones = [10, 25, 50, 75, 100, 125, 150, 175, 200, 225, 250];
    milestones.forEach(milestone => {
        const achievementName = `level_${milestone}`;
        if (this.level === milestone + 1 && !this.achievements.includes(achievementName)) {
            newAchievements.push(achievementName);
            this.achievements.push(achievementName);
        }
    });
    
    // Tier Completion Achievements
    const tierCompletions = [
        { level: 21, name: 'tier_easy' },
        { level: 41, name: 'tier_medium' },
        { level: 61, name: 'tier_hard' },
        { level: 81, name: 'tier_expert' },
        { level: 101, name: 'tier_legendary' },
        { level: 151, name: 'tier_master' },
        { level: 201, name: 'tier_grandmaster' },
        { level: 251, name: 'tier_ultimate' }
    ];
    
    tierCompletions.forEach(tier => {
        if (this.level === tier.level && !this.achievements.includes(tier.name)) {
            newAchievements.push(tier.name);
            this.achievements.push(tier.name);
        }
    });
    
    // Score milestones
    const scoreAchievements = [
        { score: 5000, name: 'score_5k' },
        { score: 10000, name: 'score_10k' },
        { score: 25000, name: 'score_25k' },
        { score: 50000, name: 'score_50k' },
        { score: 100000, name: 'score_100k' }
    ];
    
    scoreAchievements.forEach(achievement => {
        if (this.score >= achievement.score && !this.achievements.includes(achievement.name)) {
            newAchievements.push(achievement.name);
            this.achievements.push(achievement.name);
        }
    });
    
    if (newAchievements.length > 0) {
        localStorage.setItem('tiltSphereAchievements', JSON.stringify(this.achievements));
        // Could show achievement notification here
    }
}
            
            showSettings() {
                // Update UI with current settings
                document.getElementById('sensitivitySlider').value = this.settings.sensitivity;
                document.getElementById('sensitivityValue').textContent = this.settings.sensitivity;
                document.getElementById('soundToggle').checked = this.settings.sound;
                document.getElementById('hapticToggle').checked = this.settings.haptic;
                document.getElementById('trailToggle').checked = this.settings.trail;
                
                // Add slider event listener
                const slider = document.getElementById('sensitivitySlider');
                slider.oninput = () => {
                    document.getElementById('sensitivityValue').textContent = slider.value;
                };
                
                document.getElementById('settingsModal').style.display = 'flex';
            }
            
            closeSettings() {
                document.getElementById('settingsModal').style.display = 'none';
            }
            
            saveSettings() {
                // Get values from UI
                this.settings.sensitivity = parseInt(document.getElementById('sensitivitySlider').value);
                this.settings.sound = document.getElementById('soundToggle').checked;
                this.settings.haptic = document.getElementById('hapticToggle').checked;
                this.settings.trail = document.getElementById('trailToggle').checked;
                
                // Save to localStorage
                localStorage.setItem('tiltSphereSettings', JSON.stringify(this.settings));
                
                // Close modal
                this.closeSettings();
                
                // Show confirmation
                document.getElementById('saveStatus').textContent = 'Settings saved!';
                setTimeout(() => {
                    document.getElementById('saveStatus').textContent = document.getElementById('saveStatus').textContent.replace('Settings saved!', '').trim();
                }, 3000);
            }
        }
        
        // Initialize the game when page loads
        const game = new TiltBallGame();
    </script>
</body>
</html>
