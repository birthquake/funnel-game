<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>TiltSphere - Ultimate Ball Challenge</title>
    <meta name="theme-color" content="#0f0f23">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TiltSphere">
    <link rel="apple-touch-icon" href="/icon-192.png">
    <meta name="description" content="Tilt your phone to guide the ball into the target. 250 levels of increasingly devious challenges.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        html { height: 100%; overflow: hidden; }

        body {
            background: linear-gradient(135deg, #0f0f23, #1a1a2e, #16213e, #0f3460);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            font-family: 'Arial', sans-serif;
            color: #fff;
            overflow: hidden;
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        @keyframes gradientShift {
            0%   { background-position: 0% 50%; }
            50%  { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .header { text-align: center; margin-bottom: 10px; z-index: 50; }

        .title {
            font-size: 28px; font-weight: bold;
            text-shadow: 0 0 20px rgba(99,179,237,.8);
            margin-bottom: 5px;
            background: linear-gradient(45deg, #63b3ed, #4fd1c7, #68d391);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stats {
            display: flex; gap: 15px; font-size: 14px;
            margin-bottom: 8px; flex-wrap: wrap; justify-content: center;
        }

        .stat-item {
            padding: 3px 8px;
            background: rgba(99,179,237,.1);
            border-radius: 10px;
            border: 1px solid rgba(99,179,237,.3);
        }

        .progress-meter {
            width: 200px; height: 12px; background: #333;
            border: 1px solid #63b3ed; margin: 10px auto;
            border-radius: 6px; overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #68d391, #4fd1c7, #63b3ed);
            width: 0%; transition: width .5s ease;
        }

        .difficulty-badge { display:inline-block; padding:2px 8px; border-radius:10px; font-size:10px; margin-left:8px; }
        .difficulty-easy        { background:#68d391; color:#000; }
        .difficulty-medium      { background:#f6ad55; color:#000; }
        .difficulty-hard        { background:#f56565; color:#fff; }
        .difficulty-expert      { background:#9f7aea; color:#fff; }
        .difficulty-legendary   { background:#ffd700; color:#000; }
        .difficulty-master      { background:#e53e3e; color:#fff; }
        .difficulty-grandmaster { background:#1a365d; color:#fff; }
        .difficulty-ultimate    { background:#000;    color:#ffd700; }

        .game-container {
            position: relative;
            width: 350px; height: 350px;
            border: 3px solid #63b3ed;
            border-radius: 20px;
            box-shadow: 0 0 30px rgba(99,179,237,.4), inset 0 0 30px rgba(99,179,237,.1);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 350px; height: 350px;
            border-radius: 17px;
        }

        .save-indicator {
            position: absolute; top: 10px; right: 10px;
            background: rgba(104,211,145,.2); border: 1px solid #68d391;
            padding: 5px 10px; border-radius: 15px; font-size: 10px;
            color: #68d391; opacity: 0; transition: opacity .3s ease;
            pointer-events: none;
        }
        .save-indicator.show { opacity: 1; }

        .paused-overlay {
            position: absolute; inset: 0;
            background: rgba(0,0,0,.8);
            display: flex; align-items: center; justify-content: center;
            z-index: 150; opacity: 0; pointer-events: none;
            transition: opacity .3s ease; border-radius: 17px;
        }
        .paused-overlay.show { opacity: 1; pointer-events: all; }
        .paused-content { text-align: center; color: #fff; }
        .paused-content h2 { font-size: 24px; margin-bottom: 10px; color: #63b3ed; }

        .achievement-notification {
            position: fixed; top: 20px; right: -400px;
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #000; padding: 15px 20px; border-radius: 10px;
            border: 2px solid #ffd700; font-weight: bold;
            z-index: 200; transition: right .5s ease; max-width: 300px;
            box-shadow: 0 4px 20px rgba(255,215,0,.4);
        }
        .achievement-notification.show { right: 20px; }
        .achievement-title       { font-size: 16px; margin-bottom: 5px; }
        .achievement-description { font-size: 12px; opacity: .8; }

        .controls {
            text-align: center; margin-top: 15px;
            font-size: 12px; max-width: 350px; z-index: 50;
        }

        .start-button, .menu-button {
            background: linear-gradient(45deg, #63b3ed, #4fd1c7);
            border: none; color: #fff; padding: 12px 24px;
            font-family: inherit; cursor: pointer; margin: 8px;
            border-radius: 8px; font-size: 14px; font-weight: bold;
            box-shadow: 0 4px 15px rgba(99,179,237,.3);
            transition: all .3s ease;
        }
        .start-button:hover, .menu-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(99,179,237,.4);
        }
        .menu-button {
            font-size: 12px; padding: 8px 16px;
            background: linear-gradient(45deg, #4a5568, #63b3ed);
        }
        .menu-buttons {
            display: flex; gap: 10px; margin-top: 10px;
            flex-wrap: wrap; justify-content: center;
        }

        .skip-level-hint {
            font-size: 10px; color: #f6ad55; margin-top: 5px;
            opacity: 0; transition: opacity .3s ease;
        }
        .skip-level-hint.show { opacity: 1; }

        .orientation-overlay {
            display: none;
            position: fixed; inset: 0; z-index: 9999;
            background: #0f0f23;
            flex-direction: column; align-items: center; justify-content: center;
            color: #fff; text-align: center; padding: 30px;
        }
        .orientation-overlay.show { display: flex; }
        .rotate-icon {
            font-size: 64px; margin-bottom: 20px;
            animation: rotateHint 2s ease-in-out infinite;
        }
        @keyframes rotateHint {
            0%,100% { transform: rotate(0deg); }
            50%      { transform: rotate(90deg); }
        }

        .emergency-center {
            position: absolute; bottom: 10px; left: 10px;
            background: rgba(245,101,101,0.15);
            border: 1px solid rgba(245,101,101,0.6);
            color: #fc8181; padding: 6px 12px;
            border-radius: 20px; font-size: 10px; font-weight: bold;
            cursor: pointer; opacity: 0; pointer-events: none;
            transition: opacity .4s ease, background .2s ease;
            z-index: 10; user-select: none; -webkit-user-select: none;
            letter-spacing: 0.3px;
        }
        .emergency-center.show   { opacity: 1; pointer-events: all; }
        .emergency-center:active { background: rgba(245,101,101,0.35); }
    </style>
</head>
<body>

<div class="orientation-overlay" id="orientationOverlay">
    <div class="rotate-icon">üì±</div>
    <div style="font-size:18px;font-weight:bold;margin-bottom:10px">Please rotate your device</div>
    <div style="font-size:13px;opacity:.7">TiltSphere is designed for portrait mode</div>
</div>

<div class="header">
    <div class="title">TILTSPHERE</div>
    <div class="stats">
        <div class="stat-item">Level: <span id="level">1</span><span id="difficultyBadge" class="difficulty-badge difficulty-easy">EASY</span></div>
        <div class="stat-item">Score: <span id="score">0</span></div>
        <div class="stat-item">Best: <span id="bestScore">0</span></div>
        <div class="stat-item" id="livesDisplay">‚ù§Ô∏è <span id="livesCount">3</span></div>
        <div class="stat-item" id="timerDisplay">‚è± <span id="timerCount">--</span></div>
    </div>
    <div class="progress-meter"><div class="progress-fill" id="progressFill"></div></div>
    <div style="font-size:10px">Progress: <span id="progressLevel">0%</span> ‚Ä¢ <span id="achievementCount">0</span> achievements</div>
</div>

<div class="achievement-notification" id="achievementNotification">
    <div class="achievement-title"       id="achievementTitle"></div>
    <div class="achievement-description" id="achievementDescription"></div>
</div>

<div class="game-container" id="gameContainer">
    <canvas id="gameCanvas" width="350" height="350"></canvas>
    <div class="save-indicator" id="saveIndicator">Progress Saved!</div>
    <div class="paused-overlay" id="pausedOverlay">
        <div class="paused-content">
            <h2>PAUSED</h2>
            <p id="pauseMsg">Tap anywhere to resume</p>
        </div>
    </div>
    <div class="emergency-center" id="emergencyCenter">‚äï Double-tap to centre</div>
</div>

<div class="controls">
    <button class="start-button" id="startButton">START GAME</button>
    <div class="menu-buttons" id="menuButtons" style="display:none">
        <button class="menu-button" onclick="game.pauseGame()">Pause</button>
        <button class="menu-button" onclick="game.saveGame()">Save</button>
        <button class="menu-button" onclick="game.showSettings()">Settings</button>
        <button class="menu-button" onclick="game.resetProgress()">Reset</button>
        <button class="menu-button" id="skipButton" onclick="game.skipLevel()" style="display:none">Skip Level</button>
        <button class="menu-button" onclick="game.showLeaderboard()">Scores</button>
        <button class="menu-button" onclick="game.showSkinPicker()">Skins</button>
        <button class="menu-button" onclick="game.startDailyChallenge()">Daily</button>
        <button class="menu-button" onclick="game.startEndlessMode()">Endless</button>
    </div>
    <div>Tilt your device to guide the ball into the target</div>
    <div class="skip-level-hint" id="skipLevelHint">Having trouble? Skip available after 10 attempts</div>
    <div style="margin-top:5px;font-size:10px" id="saveStatus"></div>
</div>

<div id="leaderboardModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.85);z-index:100;align-items:center;justify-content:center">
    <div style="background:linear-gradient(135deg,#1a202c,#2d3748);border:2px solid #ffd700;border-radius:15px;padding:20px;width:90%;max-width:300px;color:#fff;text-align:center">
        <h3 style="color:#ffd700;margin-bottom:15px">üèÜ High Scores</h3>
        <div id="leaderboardList" style="margin-bottom:20px;font-size:13px;line-height:2"></div>
        <button onclick="game.closeLeaderboard()" style="background:#ffd700;color:#000;border:none;padding:8px 20px;border-radius:5px;cursor:pointer;font-weight:bold">Close</button>
    </div>
</div>

<div id="gameOverModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.9);z-index:200;align-items:center;justify-content:center">
    <div style="background:linear-gradient(135deg,#1a202c,#2d3748);border:2px solid #f56565;border-radius:15px;padding:25px;width:90%;max-width:300px;color:#fff;text-align:center">
        <h2 style="color:#f56565;margin-bottom:8px">GAME OVER</h2>
        <p id="gameOverMsg" style="font-size:13px;margin-bottom:15px;opacity:.8"></p>
        <div style="font-size:22px;font-weight:bold;color:#ffd700;margin-bottom:5px">Score: <span id="gameOverScore">0</span></div>
        <div style="font-size:13px;margin-bottom:5px">Level reached: <span id="gameOverLevel">1</span></div>
        <div style="font-size:13px;margin-bottom:20px">Best: <span id="gameOverBest">0</span></div>
        <div style="display:flex;gap:10px;justify-content:center">
            <button onclick="game.restartGame()" style="background:#68d391;color:#000;border:none;padding:10px 18px;border-radius:8px;cursor:pointer;font-weight:bold">Play Again</button>
            <button onclick="game.showLeaderboard()" style="background:#ffd700;color:#000;border:none;padding:10px 18px;border-radius:8px;cursor:pointer;font-weight:bold">Scores</button>
        </div>
    </div>
</div>

<div id="skinModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.85);z-index:100;align-items:center;justify-content:center">
    <div style="background:linear-gradient(135deg,#1a202c,#2d3748);border:2px solid #63b3ed;border-radius:15px;padding:20px;width:90%;max-width:300px;color:#fff;text-align:center">
        <h3 style="color:#63b3ed;margin-bottom:5px">üé® Ball Skins</h3>
        <p style="font-size:11px;opacity:.6;margin-bottom:15px">Unlock skins by earning achievements</p>
        <div id="skinGrid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-bottom:18px"></div>
        <button onclick="game.closeSkinPicker()" style="background:#63b3ed;color:#000;border:none;padding:8px 20px;border-radius:5px;cursor:pointer;font-weight:bold">Close</button>
    </div>
</div>

<div id="dailyModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.85);z-index:100;align-items:center;justify-content:center">
    <div style="background:linear-gradient(135deg,#1a202c,#2d3748);border:2px solid #68d391;border-radius:15px;padding:22px;width:90%;max-width:300px;color:#fff;text-align:center">
        <h3 style="color:#68d391;margin-bottom:5px">üìÖ Daily Challenge</h3>
        <p style="font-size:12px;opacity:.7;margin-bottom:4px">Same level layout for everyone today</p>
        <p id="dailyDateLabel" style="font-size:11px;color:#68d391;margin-bottom:15px"></p>
        <div id="dailyBestScore" style="font-size:13px;margin-bottom:15px;opacity:.8"></div>
        <div style="display:flex;gap:10px;justify-content:center">
            <button onclick="game.confirmDailyChallenge()" style="background:#68d391;color:#000;border:none;padding:10px 18px;border-radius:8px;cursor:pointer;font-weight:bold">Play!</button>
            <button onclick="game.closeDailyModal()" style="background:#4a5568;color:#fff;border:none;padding:10px 18px;border-radius:8px;cursor:pointer">Cancel</button>
        </div>
    </div>
</div>

<div id="settingsModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.8);z-index:100;align-items:center;justify-content:center">
    <div style="background:linear-gradient(135deg,#1a202c,#2d3748);border:2px solid #63b3ed;border-radius:15px;padding:20px;width:90%;max-width:300px;color:#fff">
        <h3 style="text-align:center;margin-bottom:20px;color:#63b3ed">Settings</h3>
        <div style="margin-bottom:15px">
            <label style="display:block;margin-bottom:5px">Sensitivity: <span id="sensitivityValue">50</span>%</label>
            <input type="range" id="sensitivitySlider" min="10" max="100" value="50" style="width:100%">
        </div>
        <div style="margin-bottom:15px">
            <label style="display:flex;align-items:center;gap:10px"><input type="checkbox" id="soundToggle" checked><span>Sound Effects</span></label>
        </div>
        <div style="margin-bottom:15px">
            <label style="display:flex;align-items:center;gap:10px"><input type="checkbox" id="hapticToggle" checked><span>Haptic Feedback</span></label>
        </div>
        <div style="margin-bottom:15px">
            <label style="display:flex;align-items:center;gap:10px"><input type="checkbox" id="trailToggle" checked><span>Ball Trail</span></label>
        </div>
        <div style="margin-bottom:20px">
            <label style="display:flex;align-items:center;gap:10px"><input type="checkbox" id="autoPauseToggle" checked><span>Auto-pause when window loses focus</span></label>
        </div>
        <div style="display:flex;gap:10px;justify-content:center">
            <button onclick="game.saveSettings()" style="background:#68d391;color:#000;border:none;padding:8px 16px;border-radius:5px;cursor:pointer">Save</button>
            <button onclick="game.closeSettings()" style="background:#f56565;color:#fff;border:none;padding:8px 16px;border-radius:5px;cursor:pointer">Cancel</button>
        </div>
    </div>
</div>

<script>

class TiltBallGame {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx    = this.canvas.getContext('2d');

        this.startButton          = document.getElementById('startButton');
        this.pausedOverlay        = document.getElementById('pausedOverlay');
        this.achievementNotification = document.getElementById('achievementNotification');

        this.ballX    = 165;  this.ballY    = 165;
        this.ballVelX = 0;    this.ballVelY = 0;
        this.friction    = 0.95;
        this.sensitivity = 0.5;
        this.maxVelocity = 8;
        this.ballSize    = 20;

        this.level         = 1;
        this.score         = 0;
        this.bestScore     = parseInt(localStorage.getItem('tiltSphereBest') || '0');
        this.gameRunning   = false;
        this.gamePaused    = false;
        this.levelCompleting = false;
        this.levelAttempts = 0;
        this.stuckTimer    = 0;
        this.lastBallPos   = { x: 165, y: 165 };

        this.lives         = 3;
        this.timeLeft      = 30;
        this.timerRunning  = false;
        this._timerInterval = null;
        this.gameOverActive = false;

        this.combo         = 0;
        this.levelHitCount = 0;
        this._comboPopup   = null;

        this.gameMode      = 'normal';
        this.endlessLevel  = 1;
        this.dailyDate     = '';
        this.dailySeed     = 0;

        this.activeSkin    = parseInt(localStorage.getItem('tiltSphereSkin') || '0');

        this.joystickActive   = false;
        this.joystickBase     = { x: 60, y: 290 };
        this.joystickThumb    = { x: 60, y: 290 };
        this.joystickTouchId  = null;
        this.gyroAvailable    = false;

        this.tiltOffsetBeta  = 0;
        this.tiltOffsetGamma = 0;

        this.tutorialActive  = false;
        this.tutorialProgress = 0;

        this.bgTheme = { r:45, g:55, b:72 };

        this.obstacles = [];
        this.trail = [];
        this.particles = [];
        this.shockwaves = [];
        this.scorePopups = [];

        this.nearMissProximity = 0;

        this.emergencyCenter = document.getElementById('emergencyCenter');
        this._ecTapCount = 0;
        this._ecTapTimer = null;

        this.audioCtx = null;
        this._nearMissSoundActive = false;

        this.achievements = JSON.parse(localStorage.getItem('tiltSphereAchievements') || '[]');

        this.settings = { sound:true, haptic:true, trail:true, sensitivity:50, autoPause:true };
        try {
            const s = localStorage.getItem('tiltSphereSettings');
            if (s) this.settings = { ...this.settings, ...JSON.parse(s) };
        } catch(e) { console.warn('Settings load failed', e); }

        this.W = 350;
        this.H = 350;

        this.funnelX = 280; this.funnelY = 280;
        this.funnelPulsePhase = 0;

        this.levelIntroProgress  = 0;
        this.levelIntroActive    = false;
        this.levelIntroLevel     = 1;

        this.time = 0;

        this.levelConfigs = this.generateLevelConfigs();

        this.loadGame();
        this.setupLevel();
        this.updateUI();
        this.setupEventListeners();
        this.setupAutoPause();

        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', (e) => {
                if (e.gamma !== null || e.beta !== null) this.gyroAvailable = true;
            }, { once: true });
        }

        this.setupOrientationLock();
        this.renderLoop();
    }

    generateLevelConfigs() {
        const c = [];
        for (let i = 1;   i <= 20;  i++) c.push({ funnelSize: Math.max(60-i*2,35),   obstacles: Math.min(2+Math.floor(i/3),6),          movingObstacles: 0,                              ballSpeed: 1+(i*.02),              difficulty:'easy',        specialMechanic:null });
        for (let i = 21;  i <= 40;  i++) c.push({ funnelSize: Math.max(35-(i-20)*.25,30), obstacles: Math.min(2+Math.floor((i-20)/3),6), movingObstacles: Math.min(Math.floor((i-25)/3),2), ballSpeed: 1.2+((i-20)*.03),      difficulty:'medium',      specialMechanic: i%8===0?'rotating':null });
        for (let i = 41;  i <= 60;  i++) c.push({ funnelSize: 30,                     obstacles: Math.min(4+Math.floor((i-40)/2),10),    movingObstacles: Math.min(Math.floor((i-40)/3),4), ballSpeed: 1.4+((i-40)*.04),      difficulty:'hard',        specialMechanic:['rotating','bouncy'][Math.floor((i-40)/10)%2] });
        for (let i = 61;  i <= 80;  i++) c.push({ funnelSize: 30,                     obstacles: Math.min(6+Math.floor((i-60)/2),15),    movingObstacles: Math.min(3+Math.floor((i-60)/3),6), ballSpeed: 1.6+((i-60)*.05),   difficulty:'expert',      specialMechanic:['maze','spiral'][Math.floor((i-60)/10)%2] });
        for (let i = 81;  i <= 100; i++) c.push({ funnelSize: 30,                     obstacles: Math.min(10+Math.floor((i-80)/2),20),   movingObstacles: Math.min(4+Math.floor((i-80)/2),8), ballSpeed: 1.8+((i-80)*.06),   difficulty:'legendary',   specialMechanic:['ultimate','chaos'][Math.floor((i-80)/10)%2] });
        for (let i = 101; i <= 250; i++) {
            const tier = Math.floor((i-101)/50);
            c.push({ funnelSize: 30, obstacles: Math.min(12+Math.floor((i-100)/5),35), movingObstacles: Math.min(5+Math.floor((i-100)/10),15), ballSpeed: 2.0+((i-100)*.02), difficulty: ['master','grandmaster','ultimate'][Math.min(tier,2)], specialMechanic:['master_challenge','ultimate_precision','chaos_mode'][tier%3] });
        }
        return c;
    }

    getCurrentConfig() {
        if (this.gameMode === 'endless') return this.getEndlessConfig();
        return this.levelConfigs[Math.min(this.level-1, this.levelConfigs.length-1)];
    }

    setupLevel() {
        this.obstacles  = [];
        this.trail      = [];
        this.particles  = [];
        this.shockwaves = [];
        this.scorePopups = [];

        const cfg = this.getCurrentConfig();
        const fs  = Math.max(cfg.funnelSize, 30);

        const margin = Math.max(fs + 20, 30);
        let placed = false;
        for (let a = 0; a < 50; a++) {
            this.funnelX = margin + Math.random() * (this.W - 2*margin - fs);
            this.funnelY = margin + Math.random() * (this.H - 2*margin - fs);
            const cx = this.funnelX + fs/2, cy = this.funnelY + fs/2;
            if (Math.hypot(cx-165, cy-165) >= 120) { placed = true; break; }
        }
        if (!placed) {
            const fb = [
                { x: this.W-fs-40, y: 40 }, { x: 40, y: this.H-fs-40 },
                { x: this.W-fs-40, y: this.H-fs-40 }, { x: 40, y: 40 }
            ];
            const f = fb[Math.floor(Math.random()*fb.length)];
            this.funnelX = f.x; this.funnelY = f.y;
        }

        for (let i = 0; i < cfg.obstacles;       i++) this.spawnObstacle(false, cfg);
        for (let i = 0; i < cfg.movingObstacles; i++) this.spawnObstacle(true,  cfg);

        this.ballX = 165; this.ballY = 165;
        this.ballVelX = 0; this.ballVelY = 0;
        this.levelAttempts = 0;
        this.stuckTimer    = 0;

        document.getElementById('skipLevelHint').classList.remove('show');
        document.getElementById('skipButton').style.display = 'none';

        this.updateDifficultyBadge(cfg.difficulty);

        this.levelHitCount = 0;

        if (this.gameRunning) {
            this.levelIntroLevel    = this.level;
            this.levelIntroProgress = 0.001;
            this.levelIntroActive   = true;
            this.startTimer();
        }

        if (this.level === 1 && this.gameRunning) {
            this.tutorialActive   = true;
            this.tutorialProgress = 0;
        }
    }

    spawnObstacle(isMoving, cfg) {
        const fs   = Math.max(cfg.funnelSize, 30);
        const size = 20 + Math.random() * 15;
        let x, y, valid = false;

        for (let a = 0; a < 100; a++) {
            const fcx = this.funnelX + fs/2, fcy = this.funnelY + fs/2;
            const pp  = Math.random();
            const pv  = (Math.random()-.5) * 120;
            const pa  = Math.atan2(fcy-165, fcx-165);
            const perp = pa + Math.PI/2;
            x = (165 + (fcx-165)*pp + Math.cos(perp)*pv);
            y = (165 + (fcy-165)*pp + Math.sin(perp)*pv);
            x = Math.max(20, Math.min(x, this.W-size-20));
            y = Math.max(20, Math.min(y, this.H-size-20));

            const dBall = Math.hypot(x+size/2-165, y+size/2-165);

            const overlap = !(
                x+size  < this.funnelX-20 ||
                x       > this.funnelX+fs+20 ||
                y+size  < this.funnelY-20 ||
                y       > this.funnelY+fs+20
            );

            const tooClose = this.obstacles.some(o =>
                Math.hypot(x+size/2 - o.x-o.w/2, y+size/2 - o.y-o.h/2) < (size+o.w)/2 + 15
            );

            if (dBall >= 50 && !overlap && !tooClose) { valid = true; break; }
        }

        if (!valid) {
            x = 30 + Math.random() * (this.W - 60 - size);
            y = 30 + Math.random() * (this.H - 60 - size);
        }

        const dirs      = ['x','y','diag'];
        const dir       = dirs[Math.floor(Math.random()*3)];
        const speed     = 0.3 + Math.random() * 0.5;
        const range     = 40  + Math.random() * 60;
        const phase     = Math.random() * Math.PI * 2;

        const lvl = this.level;
        let type = 'rect';
        if (lvl >= 40 && Math.random() < 0.2)      type = 'laser';
        else if (lvl >= 20 && Math.random() < 0.25) type = 'spinner';
        else if (lvl >= 10 && Math.random() < 0.3)  type = 'circle';

        let laserAngle = Math.random() * Math.PI;
        let laserLength = 50 + Math.random() * 60;
        let laserSweepSpeed = (0.015 + Math.random() * 0.02) * (Math.random() < 0.5 ? 1 : -1);

        this.obstacles.push({
            x, y, w: size, h: size,
            isMoving, dir, speed, range, startX: x, startY: y, phase,
            type,
            spinAngle: 0, spinSpeed: (0.02 + Math.random() * 0.03) * (Math.random() < 0.5 ? 1 : -1),
            laserAngle, laserLength, laserSweepSpeed,
            hitThisLevel: false
        });
    }

    setupEventListeners() {
        this.startButton.addEventListener('click', () => this.requestPermission());
        this.pausedOverlay.addEventListener('click', () => { if (this.gamePaused) this.resumeGame(); });
        this.setupEmergencyCenter();
        this.setupJoystick();
    }

    setupOrientationLock() {
        const overlay = document.getElementById('orientationOverlay');
        const check = () => {
            const landscape = window.matchMedia('(orientation: landscape)').matches;
            overlay.classList.toggle('show', landscape);
        };
        check();
        window.addEventListener('orientationchange', check);
        window.addEventListener('resize', check);
    }

    setupJoystick() {
        const canvas = this.canvas;
        canvas.addEventListener('touchstart', (e) => {
            if (!this.joystickActive) return;
            for (const t of e.changedTouches) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = this.W / rect.width;
                const tx = (t.clientX - rect.left) * scaleX;
                const ty = (t.clientY - rect.top) * scaleX;
                const dx = tx - this.joystickBase.x, dy = ty - this.joystickBase.y;
                if (Math.hypot(dx, dy) < 50) {
                    this.joystickTouchId = t.identifier;
                    break;
                }
            }
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if (!this.joystickActive || this.joystickTouchId === null) return;
            for (const t of e.changedTouches) {
                if (t.identifier !== this.joystickTouchId) continue;
                const rect  = canvas.getBoundingClientRect();
                const scaleX = this.W / rect.width;
                const tx = (t.clientX - rect.left) * scaleX;
                const ty = (t.clientY - rect.top) * scaleX;
                const dx = tx - this.joystickBase.x, dy = ty - this.joystickBase.y;
                const dist = Math.hypot(dx, dy);
                const maxR = 35;
                if (dist <= maxR) {
                    this.joystickThumb.x = tx;
                    this.joystickThumb.y = ty;
                } else {
                    this.joystickThumb.x = this.joystickBase.x + (dx/dist)*maxR;
                    this.joystickThumb.y = this.joystickBase.y + (dy/dist)*maxR;
                }
            }
            e.preventDefault();
        }, { passive: false });

        const endJoy = () => {
            this.joystickTouchId = null;
            this.joystickThumb.x = this.joystickBase.x;
            this.joystickThumb.y = this.joystickBase.y;
        };
        canvas.addEventListener('touchend',    endJoy);
        canvas.addEventListener('touchcancel', endJoy);
    }

    setupEmergencyCenter() {
        const btn = this.emergencyCenter;
        btn.addEventListener('touchend', () => {
            this._ecTapCount++;
            if (this._ecTapCount === 1) {
                this._ecTapTimer = setTimeout(() => { this._ecTapCount = 0; }, 500);
            } else if (this._ecTapCount >= 2) {
                clearTimeout(this._ecTapTimer);
                this._ecTapCount = 0;
                this.centreBall();
            }
        });
        btn.addEventListener('click', () => {
            this._ecTapCount++;
            if (this._ecTapCount === 1) {
                this._ecTapTimer = setTimeout(() => { this._ecTapCount = 0; }, 500);
            } else if (this._ecTapCount >= 2) {
                clearTimeout(this._ecTapTimer);
                this._ecTapCount = 0;
                this.centreBall();
            }
        });
    }

    centreBall() {
        if (!this.gameRunning || this.gamePaused) return;
        this.ballX = 165; this.ballY = 165;
        this.ballVelX = 0; this.ballVelY = 0;
        this.stuckTimer = 0;
        this.emergencyCenter.classList.remove('show');
        this.spawnParticles(175, 175, '#4fd1c7', 12);
    }

    initAudio() {
        if (this.audioCtx) return;
        try {
            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch(e) { console.warn('Web Audio not available'); }
    }

    _playTone(frequency, type, gainVal, duration, attack=0.01, pitchEnd=null) {
        if (!this.audioCtx || !this.settings.sound) return;
        try {
            const now  = this.audioCtx.currentTime;
            const osc  = this.audioCtx.createOscillator();
            const gain = this.audioCtx.createGain();
            osc.connect(gain);
            gain.connect(this.audioCtx.destination);
            osc.type = type;
            osc.frequency.setValueAtTime(frequency, now);
            if (pitchEnd) osc.frequency.exponentialRampToValueAtTime(pitchEnd, now + duration);
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(gainVal, now + attack);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            osc.start(now);
            osc.stop(now + duration + 0.05);
        } catch(e) {}
    }

    soundWallBounce()    { this._playTone(110, 'sine', 0.15, 0.12, 0.005, 55); }
    soundObstacleHit()   { this._playTone(220, 'sawtooth', 0.2, 0.15, 0.005, 80); setTimeout(() => this._playTone(160, 'square', 0.1, 0.10, 0.005), 30); }
    soundNearMiss() {
        if (this._nearMissSoundActive) return;
        this._nearMissSoundActive = true;
        this._playTone(440, 'sine', 0.07, 0.4, 0.05, 660);
        setTimeout(() => { this._nearMissSoundActive = false; }, 600);
    }
    soundLevelComplete() {
        [523, 659, 784].forEach((freq, i) => { setTimeout(() => this._playTone(freq, 'sine', 0.26, 0.35, 0.01), i * 130); });
        setTimeout(() => this._playTone(1047, 'sine', 0.18, 0.5, 0.01), 420);
    }

    setupAutoPause() {
        window.addEventListener('blur', () => {
            if (this.gameRunning && !this.gamePaused && this.settings.autoPause) this.pauseGame(true);
        });
        document.addEventListener('visibilitychange', () => {
            if (this.gameRunning && !this.gamePaused && this.settings.autoPause && document.hidden) this.pauseGame(true);
        });
        screen.orientation?.addEventListener('change', () => {
            if (this.gameRunning && !this.gamePaused) { this.ballVelX = 0; this.ballVelY = 0; }
        });
    }

    async requestPermission() {
        try {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                const p = await DeviceOrientationEvent.requestPermission();
                if (p === 'granted') this.startGame();
            } else { this.startGame(); }
        } catch(e) { this.startGame(); }
    }

    startGame() {
        this.initAudio();
        this.gameRunning = true; this.gamePaused = false; this.levelCompleting = false;
        this.startButton.style.display = 'none';
        document.getElementById('menuButtons').style.display = 'flex';
        window.addEventListener('deviceorientation', e => this.handleOrientation(e));
        window.addEventListener('keydown', e => this.handleKeyboard(e));
        this.lives = 3; this.combo = 0;
        document.getElementById('livesCount').textContent = this.lives;
        this.joystickActive = !this.gyroAvailable;
        this.startTimer();
        this.levelIntroLevel    = this.level;
        this.levelIntroProgress = 0.001;
        this.levelIntroActive   = true;
        this.tutorialActive     = (this.level === 1);
        this.tutorialProgress   = 0;
    }

    handleOrientation(e) {
        if (!this.gameRunning || this.gamePaused) return;
        const cfg   = this.getCurrentConfig();
        const s     = (this.settings.sensitivity/100) * this.sensitivity * cfg.ballSpeed;
        const gamma = (e.gamma||0) - this.tiltOffsetGamma;
        const beta  = (e.beta ||0) - this.tiltOffsetBeta;
        this.ballVelX += gamma * s * 0.1;
        this.ballVelY += beta  * s * 0.1;
        this.ballVelX = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.ballVelX));
        this.ballVelY = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.ballVelY));
    }

    handleKeyboard(e) {
        if (e.key === ' ') {
            e.preventDefault();
            if (!this.gameRunning) return;
            if (this.gamePaused) this.resumeGame(); else this.pauseGame();
        }
    }

    update() {
        if (!this.gameRunning || this.gamePaused || this.levelCompleting) return;

        if (this.levelIntroActive) {
            this.levelIntroProgress += 1/60;
            if (this.levelIntroProgress >= 1) {
                this.levelIntroActive   = false;
                this.levelIntroProgress = 0;
            }
            return;
        }

        this.time += 0.016;

        if (this.joystickActive && this.joystickTouchId !== null) {
            const dx = this.joystickThumb.x - this.joystickBase.x;
            const dy = this.joystickThumb.y - this.joystickBase.y;
            const cfg = this.getCurrentConfig();
            const s   = (this.settings.sensitivity/100) * this.sensitivity * cfg.ballSpeed * 0.08;
            this.ballVelX += dx * s;
            this.ballVelY += dy * s;
            this.ballVelX = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.ballVelX));
            this.ballVelY = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.ballVelY));
        }

        const dm = Math.hypot(this.ballX - this.lastBallPos.x, this.ballY - this.lastBallPos.y);
        this.stuckTimer = dm < 0.5 ? this.stuckTimer + 1 : 0;
        this.lastBallPos = { x: this.ballX, y: this.ballY };

        this.ballVelX *= this.friction;
        this.ballVelY *= this.friction;
        this.ballX    += this.ballVelX;
        this.ballY    += this.ballVelY;

        let wallHit = false;
        if (this.ballX <= 0)                    { this.ballX = 0;                    this.ballVelX =  Math.abs(this.ballVelX)*.7; this.spawnParticles(this.ballX, this.ballY, '#ff6b6b', 6); wallHit = true; }
        if (this.ballX >= this.W-this.ballSize) { this.ballX = this.W-this.ballSize; this.ballVelX = -Math.abs(this.ballVelX)*.7; this.spawnParticles(this.ballX, this.ballY, '#ff6b6b', 6); wallHit = true; }
        if (this.ballY <= 0)                    { this.ballY = 0;                    this.ballVelY =  Math.abs(this.ballVelY)*.7; this.spawnParticles(this.ballX, this.ballY, '#ff6b6b', 6); wallHit = true; }
        if (this.ballY >= this.H-this.ballSize) { this.ballY = this.H-this.ballSize; this.ballVelY = -Math.abs(this.ballVelY)*.7; this.spawnParticles(this.ballX, this.ballY, '#ff6b6b', 6); wallHit = true; }
        if (wallHit) { this.shakeCanvas(); this.soundWallBounce(); }

        this.obstacles.forEach(o => {
            if (o.type === 'spinner') o.spinAngle += o.spinSpeed;
            if (o.type === 'laser')   o.laserAngle += o.laserSweepSpeed;

            if (!o.isMoving) return;
            const t = this.time * o.speed * Math.PI * 2 / 3 + o.phase;
            if      (o.dir === 'x')  { o.x = o.startX + Math.sin(t) * o.range; }
            else if (o.dir === 'y')  { o.y = o.startY + Math.sin(t) * o.range; }
            else                     { o.x = o.startX + Math.sin(t) * o.range * .7;
                                       o.y = o.startY + Math.cos(t) * o.range * .7; }
            o.x = Math.max(5, Math.min(o.x, this.W - o.w - 5));
            o.y = Math.max(5, Math.min(o.y, this.H - o.h - 5));
        });

        this.obstacles.forEach(o => {
            const bcx = this.ballX + this.ballSize/2, bcy = this.ballY + this.ballSize/2;
            const br  = this.ballSize / 2;
            let hit   = false;

            if (o.type === 'circle') {
                const cx = o.x + o.w/2, cy = o.y + o.h/2, cr = o.w/2;
                const dist = Math.hypot(bcx-cx, bcy-cy);
                if (dist < br + cr) {
                    hit = true;
                    const nx = (bcx-cx)/dist, ny = (bcy-cy)/dist;
                    const overlap = br + cr - dist;
                    this.ballX += nx * overlap;
                    this.ballY += ny * overlap;
                    const dot = this.ballVelX*nx + this.ballVelY*ny;
                    this.ballVelX = (this.ballVelX - 2*dot*nx) * 0.65;
                    this.ballVelY = (this.ballVelY - 2*dot*ny) * 0.65;
                }
            } else if (o.type === 'laser') {
                const cx = o.x + o.w/2, cy = o.y + o.h/2;
                const hl = o.laserLength / 2;
                const lx1 = cx + Math.cos(o.laserAngle) * hl;
                const ly1 = cy + Math.sin(o.laserAngle) * hl;
                const lx2 = cx - Math.cos(o.laserAngle) * hl;
                const ly2 = cy - Math.sin(o.laserAngle) * hl;
                const dx = lx2-lx1, dy = ly2-ly1;
                const lenSq = dx*dx + dy*dy;
                let t = ((bcx-lx1)*dx + (bcy-ly1)*dy) / lenSq;
                t = Math.max(0, Math.min(1, t));
                const closestX = lx1 + t*dx, closestY = ly1 + t*dy;
                const distToLine = Math.hypot(bcx-closestX, bcy-closestY);
                if (distToLine < br + 4) {
                    hit = true;
                    const nx = (bcx-closestX)/distToLine, ny = (bcy-closestY)/distToLine;
                    const overlap = br + 4 - distToLine;
                    this.ballX += nx * overlap;
                    this.ballY += ny * overlap;
                    const dot = this.ballVelX*nx + this.ballVelY*ny;
                    this.ballVelX = (this.ballVelX - 2*dot*nx) * 0.65;
                    this.ballVelY = (this.ballVelY - 2*dot*ny) * 0.65;
                }
            } else {
                if (this.ballX < o.x+o.w && this.ballX+this.ballSize > o.x &&
                    this.ballY < o.y+o.h && this.ballY+this.ballSize > o.y) {
                    hit = true;
                    const overlapLeft   = (o.x + o.w) - this.ballX;
                    const overlapRight  = (this.ballX + this.ballSize) - o.x;
                    const overlapTop    = (o.y + o.h) - this.ballY;
                    const overlapBottom = (this.ballY + this.ballSize) - o.y;
                    const minOverlapX = Math.min(overlapLeft, overlapRight);
                    const minOverlapY = Math.min(overlapTop, overlapBottom);
                    if (minOverlapX < minOverlapY) {
                        if (overlapLeft < overlapRight) { this.ballX = o.x + o.w; this.ballVelX = Math.abs(this.ballVelX) * 0.6; }
                        else { this.ballX = o.x - this.ballSize; this.ballVelX = -Math.abs(this.ballVelX) * 0.6; }
                        this.ballVelY *= 0.85;
                    } else {
                        if (overlapTop < overlapBottom) { this.ballY = o.y + o.h; this.ballVelY = Math.abs(this.ballVelY) * 0.6; }
                        else { this.ballY = o.y - this.ballSize; this.ballVelY = -Math.abs(this.ballVelY) * 0.6; }
                        this.ballVelX *= 0.85;
                    }
                    this.ballVelX = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.ballVelX));
                    this.ballVelY = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.ballVelY));
                }
            }

            if (hit) {
                this.ballVelX = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.ballVelX));
                this.ballVelY = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.ballVelY));
                this.spawnParticles(bcx, bcy, o.isMoving ? '#9f7aea' : (o.type==='laser'?'#fc8181':o.type==='circle'?'#4fd1c7':'#d69e2e'), 6);
                this.shakeCanvas();
                this.soundObstacleHit();
                if (this.settings.haptic && navigator.vibrate) navigator.vibrate([30,10,30]);
                this.levelAttempts++;
                this.levelHitCount++;
                this.combo = 0;
                this.checkSkipLevelAvailability();
            }
        });

        if (!this.levelCompleting) {
            const cfg = this.getCurrentConfig();
            const fs  = Math.max(cfg.funnelSize, 30);
            const fcx = this.funnelX + fs/2, fcy = this.funnelY + fs/2;
            const bcx = this.ballX + this.ballSize/2, bcy = this.ballY + this.ballSize/2;
            const distToFunnel = Math.hypot(bcx-fcx, bcy-fcy);

            if (distToFunnel < fs/2 - 5) { this.levelComplete(); }

            const nearZone = fs * 1.8;
            this.nearMissProximity = Math.max(0, 1 - (distToFunnel - fs/2) / nearZone);

            if (this.nearMissProximity > 0.65) this.soundNearMiss();
            else this._nearMissSoundActive = false;
        }

        if (this.gameRunning && !this.gamePaused) {
            if (this.stuckTimer > 300) { this.emergencyCenter.classList.add('show'); }
            else { this.emergencyCenter.classList.remove('show'); }
        }

        if (this.settings.trail) {
            this.trail.push({ x: this.ballX+this.ballSize/2, y: this.ballY+this.ballSize/2, alpha:1 });
            if (this.trail.length > 20) this.trail.shift();
        }

        this.particles = this.particles.filter(p => {
            p.x += p.vx; p.y += p.vy; p.vy += .15;
            p.life--;
            return p.life > 0;
        });

        this.shockwaves = this.shockwaves.filter(s => { s.radius += 4; s.life--; return s.life > 0; });
        this.scorePopups = this.scorePopups.filter(p => { p.y -= 1; p.life--; return p.life > 0; });

        if (this.tutorialActive) {
            const moving = Math.abs(this.ballVelX) > 0.3 || Math.abs(this.ballVelY) > 0.3;
            this.tutorialProgress += moving ? 0.025 : 0.004;
            if (this.tutorialProgress >= 1) this.tutorialActive = false;
        }

        const target = this.getBgTargetColour();
        this.bgTheme.r += (target.r - this.bgTheme.r) * 0.005;
        this.bgTheme.g += (target.g - this.bgTheme.g) * 0.005;
        this.bgTheme.b += (target.b - this.bgTheme.b) * 0.005;
    }

    shakeCanvas() {
        if (this._shakeTimer) return;
        let t = 0;
        const shake = () => {
            t++;
            this.shakeOffsetX = (Math.random()-.5) * 6 * (1 - t/8);
            this.shakeOffsetY = (Math.random()-.5) * 6 * (1 - t/8);
            if (t < 8) this._shakeTimer = requestAnimationFrame(shake);
            else { this.shakeOffsetX = 0; this.shakeOffsetY = 0; this._shakeTimer = null; }
        };
        this._shakeTimer = requestAnimationFrame(shake);
    }

    spawnParticles(x, y, color, count=8) {
        for (let i = 0; i < count; i++) {
            const angle = (Math.PI*2*i)/count + Math.random()*.3;
            const speed = 2 + Math.random()*3;
            this.particles.push({ x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed - Math.random()*2, life: 20 + Math.random()*20, color, size: 2 + Math.random()*3 });
        }
    }

    spawnExplosion(x, y) {
        const colors = ['#68d391','#ffd700','#4fd1c7','#f56565','#63b3ed'];
        for (let i = 0; i < 40; i++) {
            const angle = Math.random()*Math.PI*2;
            const speed = 2 + Math.random()*6;
            this.particles.push({ x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed - Math.random()*3, life: 40 + Math.random()*30, color: colors[Math.floor(Math.random()*colors.length)], size: 3 + Math.random()*4 });
        }
    }

    renderLoop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.renderLoop());
    }

    draw() {
        const ctx = this.ctx;
        const sx  = this.shakeOffsetX || 0;
        const sy  = this.shakeOffsetY || 0;

        ctx.clearRect(0, 0, this.W, this.H);

        const tr = Math.round(this.bgTheme.r), tg = Math.round(this.bgTheme.g), tb = Math.round(this.bgTheme.b);
        const bg = ctx.createRadialGradient(175,175,10, 175,175,250);
        bg.addColorStop(0, `rgb(${tr+17},${tg+19},${tb+24})`);
        bg.addColorStop(1, `rgb(${tr},${tg},${tb})`);
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, this.W, this.H);

        this.drawGrid(ctx);

        ctx.save();
        ctx.translate(sx, sy);

        this.drawTrail(ctx);
        this.drawFunnel(ctx);
        this.drawObstacles(ctx);
        this.drawParticles(ctx);
        this.drawShockwaves(ctx);
        this.drawBall(ctx);
        this.drawScorePopups(ctx);

        if (this.tutorialActive && this.gameRunning && !this.levelIntroActive) this.drawTutorial(ctx);
        if (this.joystickActive && this.gameRunning && !this.gamePaused && !this.levelIntroActive) this.drawJoystick(ctx);
        if (this.levelIntroActive) this.drawLevelIntro(ctx);

        ctx.restore();
    }

    drawLevelIntro(ctx) {
        const p = this.levelIntroProgress;
        let alpha, scale;
        if (p < 0.3)      { alpha = p / 0.3; scale = 0.4 + (p / 0.3) * 0.6; }
        else if (p < 0.7) { alpha = 1; scale = 1; }
        else              { alpha = 1 - (p - 0.7) / 0.3; scale = 1 + (p - 0.7) * 0.5; }

        const cfg  = this.getCurrentConfig();
        const diff = cfg.difficulty.toUpperCase();
        const diffColors = { EASY:'#68d391', MEDIUM:'#f6ad55', HARD:'#f56565', EXPERT:'#9f7aea', LEGENDARY:'#ffd700', MASTER:'#e53e3e', GRANDMASTER:'#63b3ed', ULTIMATE:'#ffd700' };
        const col = diffColors[diff] || '#63b3ed';

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(this.W/2, this.H/2);
        ctx.scale(scale, scale);

        ctx.fillStyle = `rgba(0,0,0,0.55)`;
        ctx.fillRect(-this.W/2/scale, -this.H/2/scale, this.W/scale, this.H/scale);

        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.shadowColor = col; ctx.shadowBlur = 30;
        ctx.fillStyle = '#ffffff'; ctx.font = 'bold 64px Arial';
        ctx.fillText(`${this.levelIntroLevel}`, 0, -18);

        ctx.font = 'bold 14px Arial'; ctx.fillStyle = col; ctx.shadowBlur = 12;
        ctx.fillText('LEVEL', 0, -52);

        ctx.font = 'bold 13px Arial'; ctx.fillStyle = col; ctx.shadowBlur = 8;
        ctx.fillText(diff, 0, 20);

        ctx.shadowBlur = 0; ctx.strokeStyle = col; ctx.globalAlpha = alpha * 0.6; ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(-80, 0); ctx.lineTo(-28, 0); ctx.stroke();
        ctx.beginPath(); ctx.moveTo( 28, 0); ctx.lineTo( 80, 0); ctx.stroke();

        ctx.restore();
    }

    drawGrid(ctx) {
        ctx.save();
        ctx.strokeStyle = 'rgba(99,179,237,0.04)'; ctx.lineWidth = 1;
        for (let x = 0; x <= this.W; x += 35) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,this.H); ctx.stroke(); }
        for (let y = 0; y <= this.H; y += 35) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(this.W,y); ctx.stroke(); }
        ctx.restore();
    }

    drawTrail(ctx) {
        if (!this.trail.length) return;
        this.trail.forEach((pt, i) => {
            const t = i / this.trail.length;
            const r = 2 + t * 7;
            const alpha = t * 0.55;
            ctx.save();
            const g = ctx.createRadialGradient(pt.x, pt.y, 0, pt.x, pt.y, r*2);
            g.addColorStop(0, `rgba(245,101,101,${alpha})`);
            g.addColorStop(1, `rgba(245,101,101,0)`);
            ctx.fillStyle = g;
            ctx.beginPath(); ctx.arc(pt.x, pt.y, r*2, 0, Math.PI*2); ctx.fill();
            ctx.restore();
        });
    }

    drawFunnel(ctx) {
        const cfg  = this.getCurrentConfig();
        const fs   = Math.max(cfg.funnelSize, 30);
        const cx   = this.funnelX + fs/2;
        const cy   = this.funnelY + fs/2;
        const r    = fs/2;
        const nm   = this.nearMissProximity;

        const pulseSpeed = 0.05 + nm * 0.18;
        this.funnelPulsePhase += pulseSpeed;
        const pulseAmt = 0.05 + nm * 0.12;
        const pulse    = 1 + Math.sin(this.funnelPulsePhase) * pulseAmt;

        const glowAlpha  = 0.25 + nm * 0.55;
        const glowRadius = r * (2 + nm * 1.5);

        ctx.save();

        const glow = ctx.createRadialGradient(cx, cy, r*0.3, cx, cy, glowRadius);
        glow.addColorStop(0, `rgba(104,211,145,${glowAlpha})`);
        glow.addColorStop(0.6, `rgba(104,211,145,${glowAlpha * 0.3})`);
        glow.addColorStop(1, 'rgba(104,211,145,0)');
        ctx.fillStyle = glow;
        ctx.beginPath(); ctx.arc(cx, cy, glowRadius, 0, Math.PI*2); ctx.fill();

        if (nm > 0.5) {
            const urgency = (nm - 0.5) * 2;
            const ug = ctx.createRadialGradient(cx, cy, r*0.5, cx, cy, r*1.6);
            ug.addColorStop(0, `rgba(255,237,100,${urgency * 0.3})`);
            ug.addColorStop(1, 'rgba(255,237,100,0)');
            ctx.fillStyle = ug;
            ctx.beginPath(); ctx.arc(cx, cy, r*1.6, 0, Math.PI*2); ctx.fill();
        }

        const grad = ctx.createRadialGradient(cx-r*.3, cy-r*.3, r*.1, cx, cy, r);
        grad.addColorStop(0, `hsl(${141 + nm*15}, ${80+nm*20}%, ${65+nm*15}%)`);
        grad.addColorStop(0.5, '#48bb78');
        grad.addColorStop(1, '#276749');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(cx, cy, r*pulse, 0, Math.PI*2); ctx.fill();

        ctx.strokeStyle = `rgba(255,255,255,${0.4 + nm*0.3})`; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(cx-r*.15, cy-r*.15, r*.4, Math.PI*1.1, Math.PI*1.9); ctx.stroke();

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(this.time * (1.5 + nm * 3));
        ctx.setLineDash([4, 6]);
        ctx.strokeStyle = `rgba(104,211,145,${0.6 + nm*0.35})`; ctx.lineWidth = 1.5 + nm * 1.5;
        ctx.beginPath(); ctx.arc(0, 0, r*pulse + 5, 0, Math.PI*2); ctx.stroke();
        ctx.restore();

        ctx.strokeStyle = `rgba(104,211,145,${0.8 + nm*0.2})`; ctx.lineWidth = 2 + nm * 2;
        ctx.shadowColor = '#68d391'; ctx.shadowBlur = nm * 20;
        ctx.setLineDash([]);
        ctx.beginPath(); ctx.arc(cx, cy, r*pulse, 0, Math.PI*2); ctx.stroke();

        ctx.restore();
    }

    drawObstacles(ctx) {
        this.obstacles.forEach(o => {
            const cx = o.x + o.w/2, cy = o.y + o.h/2;
            ctx.save();

            if (o.type === 'circle') {
                const r = o.w/2;
                if (o.isMoving) {
                    const g = ctx.createRadialGradient(cx,cy,0,cx,cy,r*1.8);
                    g.addColorStop(0,'rgba(79,209,197,.3)'); g.addColorStop(1,'rgba(79,209,197,0)');
                    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx,cy,r*1.8,0,Math.PI*2); ctx.fill();
                }
                const grad = ctx.createRadialGradient(cx-r*.3,cy-r*.3,r*.1,cx,cy,r);
                grad.addColorStop(0, o.isMoving ? '#4fd1c7' : '#d69e2e');
                grad.addColorStop(1, o.isMoving ? '#2c7a7b' : '#744210');
                ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
                ctx.strokeStyle = o.isMoving ? '#4fd1c7' : '#d69e2e'; ctx.lineWidth=1.5;
                ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();
                ctx.strokeStyle='rgba(255,255,255,0.3)'; ctx.lineWidth=1;
                ctx.beginPath(); ctx.arc(cx-r*.2,cy-r*.2,r*.4,Math.PI*1.1,Math.PI*1.9); ctx.stroke();
                ctx.restore(); return;
            }

            if (o.type === 'laser') {
                const hl = o.laserLength/2;
                const x1 = cx + Math.cos(o.laserAngle)*hl, y1 = cy + Math.sin(o.laserAngle)*hl;
                const x2 = cx - Math.cos(o.laserAngle)*hl, y2 = cy - Math.sin(o.laserAngle)*hl;
                ctx.shadowColor = '#f56565'; ctx.shadowBlur = 14;
                const grad = ctx.createLinearGradient(x1,y1,x2,y2);
                grad.addColorStop(0,'rgba(245,101,101,0)');
                grad.addColorStop(0.5,'rgba(245,101,101,1)');
                grad.addColorStop(1,'rgba(245,101,101,0)');
                ctx.strokeStyle=grad; ctx.lineWidth=3;
                ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
                ctx.shadowBlur=0; ctx.strokeStyle='rgba(255,200,200,0.8)'; ctx.lineWidth=1;
                ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
                ctx.fillStyle='#f56565'; ctx.beginPath(); ctx.arc(cx,cy,4,0,Math.PI*2); ctx.fill();
                ctx.restore(); return;
            }

            ctx.translate(cx, cy);

            if (o.type === 'spinner') {
                ctx.rotate(o.spinAngle);
                const arm = o.w * 0.45, thick = o.w * 0.22;
                ctx.fillStyle = o.isMoving ? '#805ad5' : '#c05621';
                ctx.shadowColor = o.isMoving ? '#9f7aea' : '#d69e2e'; ctx.shadowBlur = 8;
                ctx.fillRect(-arm, -thick/2, arm*2, thick);
                ctx.fillRect(-thick/2, -arm, thick, arm*2);
                ctx.strokeStyle = o.isMoving ? '#9f7aea' : '#d69e2e'; ctx.lineWidth = 1; ctx.shadowBlur = 0;
                ctx.strokeRect(-arm, -thick/2, arm*2, thick);
                ctx.strokeRect(-thick/2, -arm, thick, arm*2);
                ctx.restore(); return;
            }

            if (o.isMoving) {
                const glowG = ctx.createRadialGradient(0,0,0, 0,0, Math.max(o.w,o.h));
                glowG.addColorStop(0, 'rgba(159,122,234,0.3)'); glowG.addColorStop(1, 'rgba(159,122,234,0)');
                ctx.fillStyle = glowG; ctx.fillRect(-o.w/2-8, -o.h/2-8, o.w+16, o.h+16);
                const g = ctx.createLinearGradient(-o.w/2,-o.h/2, o.w/2, o.h/2);
                g.addColorStop(0, '#553c9a'); g.addColorStop(1, '#805ad5');
                ctx.fillStyle = g;
                this.roundRect(ctx, -o.w/2, -o.h/2, o.w, o.h, 5); ctx.fill();
                ctx.strokeStyle = '#9f7aea'; ctx.lineWidth = 1.5;
                this.roundRect(ctx, -o.w/2, -o.h/2, o.w, o.h, 5); ctx.stroke();
                const stripeAlpha = 0.2 + Math.sin(this.time*4 + o.phase)*0.15;
                ctx.fillStyle = `rgba(255,255,255,${stripeAlpha})`;
                ctx.fillRect(-o.w/2+2, -2, o.w-4, 4);
            } else {
                const g = ctx.createLinearGradient(-o.w/2,-o.h/2, o.w/2, o.h/2);
                g.addColorStop(0, '#975a16'); g.addColorStop(1, '#744210');
                ctx.fillStyle = g;
                this.roundRect(ctx, -o.w/2, -o.h/2, o.w, o.h, 4); ctx.fill();
                ctx.strokeStyle = '#d69e2e'; ctx.lineWidth = 1;
                this.roundRect(ctx, -o.w/2, -o.h/2, o.w, o.h, 4); ctx.stroke();
                ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(-o.w/2+4, -o.h/2+2); ctx.lineTo(o.w/2-4, -o.h/2+2); ctx.stroke();
            }
            ctx.restore();
        });
    }

    roundRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x+r, y); ctx.lineTo(x+w-r, y); ctx.quadraticCurveTo(x+w, y, x+w, y+r);
        ctx.lineTo(x+w, y+h-r); ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
        ctx.lineTo(x+r, y+h); ctx.quadraticCurveTo(x, y+h, x, y+h-r);
        ctx.lineTo(x, y+r); ctx.quadraticCurveTo(x, y, x+r, y);
        ctx.closePath();
    }

    drawBall(ctx) {
        const cx = this.ballX + this.ballSize/2;
        const cy = this.ballY + this.ballSize/2;
        const r  = this.ballSize/2 * (this._ballAnimScale ?? 1);
        if (r <= 0) return;

        ctx.save();
        ctx.globalAlpha = this._ballAnimOpacity ?? 1;

        const skinGlows = ['rgba(245,101,101,ALPHA)','rgba(99,179,237,ALPHA)','rgba(104,211,145,ALPHA)','rgba(255,215,0,ALPHA)','rgba(183,148,244,ALPHA)'];
        const glowBase = (skinGlows[this.activeSkin]||skinGlows[0]).replace('ALPHA','0.4');
        const glowFade = (skinGlows[this.activeSkin]||skinGlows[0]).replace('ALPHA','0');
        const glow = ctx.createRadialGradient(cx,cy,r*.5, cx,cy,r*2.5);
        glow.addColorStop(0, glowBase); glow.addColorStop(1, glowFade);
        ctx.fillStyle = glow;
        ctx.beginPath(); ctx.arc(cx,cy,r*2.5,0,Math.PI*2); ctx.fill();

        const skinPalettes = [
            ['#ffffff','#fc8181','#c53030'],
            ['#ffffff','#63b3ed','#1a56a0'],
            ['#ffffff','#68d391','#276749'],
            ['#ffffff','#ffd700','#b7791f'],
            ['#ffffff','#b794f4','#553c9a'],
        ];
        const pal = skinPalettes[this.activeSkin] || skinPalettes[0];
        const gR = ctx.createRadialGradient(cx-r*.3,cy-r*.4,r*.1, cx,cy,r);
        gR.addColorStop(0, pal[0]); gR.addColorStop(0.3, pal[1]); gR.addColorStop(1, pal[2]);
        ctx.fillStyle = gR;
        ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();

        const hl = ctx.createRadialGradient(cx-r*.3,cy-r*.35,0, cx-r*.3,cy-r*.35,r*.5);
        hl.addColorStop(0, 'rgba(255,255,255,0.7)'); hl.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = hl;
        ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();

        const speed = Math.hypot(this.ballVelX, this.ballVelY);
        if (speed > 2 && !this.levelCompleting) {
            const mx = -this.ballVelX*2, my = -this.ballVelY*2;
            const streak = ctx.createLinearGradient(cx,cy, cx+mx,cy+my);
            const streakCol = (skinGlows[this.activeSkin]||skinGlows[0]).replace('ALPHA', Math.min(speed/this.maxVelocity*.6,0.5).toString());
            const streakFade = (skinGlows[this.activeSkin]||skinGlows[0]).replace('ALPHA','0');
            streak.addColorStop(0, streakCol); streak.addColorStop(1, streakFade);
            ctx.fillStyle = streak;
            ctx.beginPath(); ctx.arc(cx,cy,r*.8,0,Math.PI*2); ctx.fill();
        }

        ctx.restore();

        if (!this.levelCompleting) { this._ballAnimScale = 1; this._ballAnimOpacity = 1; }
    }

    drawParticles(ctx) {
        this.particles.forEach(p => {
            const alpha = p.life / (p.life + 10);
            ctx.save();
            ctx.globalAlpha = alpha * 0.9; ctx.fillStyle = p.color;
            ctx.shadowColor = p.color; ctx.shadowBlur = 6;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
            ctx.restore();
        });
    }

    drawShockwaves(ctx) {
        this.shockwaves.forEach(s => {
            const t = 1 - s.life / s.maxLife;
            ctx.save();
            ctx.globalAlpha = (1-t) * 0.7; ctx.strokeStyle = '#68d391';
            ctx.lineWidth = 3 * (1-t); ctx.shadowColor = '#68d391'; ctx.shadowBlur = 15;
            ctx.beginPath(); ctx.arc(s.x, s.y, s.radius, 0, Math.PI*2); ctx.stroke();
            ctx.restore();
        });
    }

    drawScorePopups(ctx) {
        this.scorePopups.forEach(p => {
            const t = p.life / p.maxLife;
            ctx.save();
            ctx.globalAlpha = t; ctx.fillStyle = p.color || '#ffd700';
            ctx.font = `bold ${14 + (1-t)*6}px Arial`; ctx.textAlign = 'center';
            ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 10;
            ctx.fillText(p.text, p.x, p.y);
            ctx.restore();
        });
    }

    levelComplete() {
        if (this.levelCompleting) return;
        this.levelCompleting = true;
        this.stopTimer();

        const cfg = this.getCurrentConfig();
        const fs  = Math.max(cfg.funnelSize, 30);
        const fcx = this.funnelX + fs/2, fcy = this.funnelY + fs/2;

        for (let i = 0; i < 3; i++) {
            setTimeout(() => { this.shockwaves.push({ x:fcx, y:fcy, radius:5, maxRadius:fs*2, life:30, maxLife:30 }); }, i * 150);
        }

        this.spawnExplosion(fcx, fcy);

        const mult  = this.levelHitCount === 0 ? (this.combo++, this.getComboMultiplier()) : (this.combo = 0, 1);
        const bonus = Math.round(this.level * 100 * mult);
        this.score += bonus;
        this.levelHitCount = 0;

        const popColor = mult > 1 ? '#ffd700' : '#68d391';
        this.scorePopups.push({ x: fcx, y: fcy - 20, text: `+${bonus}`, life: 60, maxLife: 60, color: popColor });
        this.showComboPopup(mult, fcx, fcy);

        if (this.score > this.bestScore) {
            this.bestScore = this.score;
            try { localStorage.setItem('tiltSphereBest', this.bestScore.toString()); } catch(e) {}
        }

        if (this.settings.haptic && navigator.vibrate) navigator.vibrate([80,50,80,50,80,50,200]);
        this.soundLevelComplete();
        this.checkAchievements();

        if (this.gameMode === 'daily')   this.saveDailyScore();
        if (this.gameMode === 'endless') { this.endlessLevel++; this.saveEndlessScore(); }

        this.level++;

        if (this.gameMode === 'normal' && this.level > this.levelConfigs.length) { this.endGame(); return; }

        this.saveGame();
        this.updateUI();

        this.animateBallIntoFunnel(fcx, fcy, () => {
            this.setupLevel();
            this.levelCompleting = false;
        });
    }

    animateBallIntoFunnel(fcx, fcy, callback) {
        this.ballVelX = 0; this.ballVelY = 0;
        const startTime = Date.now();
        const duration  = 1000;
        const initR = Math.hypot(this.ballX+this.ballSize/2 - fcx, this.ballY+this.ballSize/2 - fcy);

        const animate = () => {
            const progress = Math.min((Date.now()-startTime)/duration, 1);
            if (progress >= 1) { setTimeout(callback, 200); return; }

            const ease   = 1 - Math.pow(1-progress, 3);
            const radius = initR * (1-ease);
            const angle  = progress * Math.PI * 6;
            const scale  = 1 - progress * 0.9;

            this.ballX = fcx + Math.cos(angle)*radius - this.ballSize/2;
            this.ballY = fcy + Math.sin(angle)*radius - this.ballSize/2;
            this._ballAnimScale  = Math.max(scale, 0.05);
            this._ballAnimOpacity = scale;

            if (Math.random() < 0.3) this.spawnParticles(this.ballX+this.ballSize/2, this.ballY+this.ballSize/2, '#4fd1c7', 2);
            requestAnimationFrame(animate);
        };
        animate();
    }

    endGame() {
        this.gameRunning = false; this.levelCompleting = false;
        alert(`üéâ Congratulations!\n\nYou completed all ${this.levelConfigs.length} levels!\nFinal Score: ${this.score}\nBest Score: ${this.bestScore}\n\nYou are a TiltSphere Master!`);
        this.level = 1; this.score = 0;
        this.startButton.style.display = 'block'; this.startButton.textContent = 'PLAY AGAIN';
        document.getElementById('menuButtons').style.display = 'none';
        this.setupLevel(); this.updateUI();
    }

    pauseGame(auto=false) {
        if (!this.gameRunning) return;
        this.gamePaused = true;
        this.pausedOverlay.classList.add('show');
        document.getElementById('pauseMsg').textContent = auto ? 'Game auto-paused ‚Äî Click to resume' : 'Click anywhere to resume';
    }

    resumeGame() {
        if (!this.gamePaused) return;
        this.gamePaused = false;
        this.pausedOverlay.classList.remove('show');
        this.ballVelX = 0; this.ballVelY = 0;
    }

    checkSkipLevelAvailability() {
        if (this.levelAttempts >= 10) {
            document.getElementById('skipLevelHint').classList.add('show');
            document.getElementById('skipButton').style.display = 'inline-block';
        }
    }

    skipLevel() {
        if (this.levelAttempts < 10) return;
        if (confirm("Skip this level? You won't get points for it.")) {
            this.level++;
            if (this.level > this.levelConfigs.length) { this.endGame(); return; }
            this.saveGame(); this.updateUI(); this.setupLevel();
            this.showNotification('Level Skipped','No points awarded',2000);
        }
    }

    resetProgress() {
        if (!confirm('Reset all progress? This cannot be undone.')) return;
        try { ['tiltSphereSave','tiltSphereBest','tiltSphereAchievements','tiltSphereSettings','tiltSphereScores'].forEach(k => localStorage.removeItem(k)); } catch(e) {}
        this.level=1; this.score=0; this.bestScore=0; this.achievements=[]; this.lives=3; this.combo=0;
        this.levelAttempts=0; this.gameRunning=false; this.levelCompleting=false;
        this.stopTimer();
        this.settings={ sound:true,haptic:true,trail:true,sensitivity:50,autoPause:true };
        this.startButton.style.display='block'; this.startButton.textContent='START GAME';
        document.getElementById('menuButtons').style.display='none';
        document.getElementById('skipLevelHint').classList.remove('show');
        document.getElementById('skipButton').style.display='none';
        this.setupLevel(); this.updateUI();
        document.getElementById('saveStatus').textContent='Progress reset';
    }

    saveGame() {
        try {
            localStorage.setItem('tiltSphereSave', JSON.stringify({ level:this.level, score:this.score, achievements:this.achievements, timestamp:Date.now(), version:'3.0' }));
            const ind = document.getElementById('saveIndicator');
            ind.classList.add('show');
            setTimeout(() => ind.classList.remove('show'), 2000);
            document.getElementById('saveStatus').textContent = `Last saved: ${new Date().toLocaleTimeString()}`;
        } catch(e) { document.getElementById('saveStatus').textContent = 'Save failed ‚Äî storage full?'; }
    }

    loadGame() {
        try {
            const raw = localStorage.getItem('tiltSphereSave');
            if (raw) {
                const d = JSON.parse(raw);
                this.level=d.level||1; this.score=d.score||0; this.achievements=d.achievements||[];
                document.getElementById('saveStatus').textContent = `Loaded: ${new Date(d.timestamp).toLocaleString()}`;
            }
        } catch(e) { document.getElementById('saveStatus').textContent = 'Failed to load save'; }
    }

    checkAchievements() {
        const n = [];
        const push = name => { if (!this.achievements.includes(name)) { n.push(name); this.achievements.push(name); } };
        if (this.level === 2) push('first_win');
        [10,25,50,75,100,125,150,175,200,225,250].forEach(m => { if (this.level===m+1) push(`level_${m}`); });
        [{l:21,n:'tier_easy'},{l:41,n:'tier_medium'},{l:61,n:'tier_hard'},{l:81,n:'tier_expert'},{l:101,n:'tier_legendary'},{l:151,n:'tier_master'},{l:201,n:'tier_grandmaster'},{l:251,n:'tier_ultimate'}]
            .forEach(t => { if (this.level===t.l) push(t.n); });
        [{s:5000,n:'score_5k'},{s:10000,n:'score_10k'},{s:25000,n:'score_25k'},{s:50000,n:'score_50k'},{s:100000,n:'score_100k'}]
            .forEach(a => { if (this.score>=a.s) push(a.n); });
        if (n.length) {
            try { localStorage.setItem('tiltSphereAchievements', JSON.stringify(this.achievements)); } catch(e) {}
            this.showAchievementNotification(n[0]);
            n.slice(1).forEach((a,i) => setTimeout(()=>this.showAchievementNotification(a),(i+1)*5000));
        }
    }

    getAchievementData(name) {
        return ({
            first_win:{title:'üéâ First Victory!',description:'Completed your first level!'},
            level_10:{title:'üîü Ten Levels Down!',description:'Reached level 10'},
            level_25:{title:'üåü Quarter Century!',description:'Reached level 25'},
            level_50:{title:'‚≠ê Halfway There!',description:'Reached level 50'},
            level_75:{title:'üí´ Three Quarters!',description:'Reached level 75'},
            level_100:{title:'üíØ Century Mark!',description:'Reached level 100'},
            level_125:{title:'üöÄ Beyond Limits!',description:'Reached level 125'},
            level_150:{title:'‚ö° Lightning Fast!',description:'Reached level 150'},
            level_175:{title:'üåà Almost There!',description:'Reached level 175'},
            level_200:{title:'üèÜ Legendary Status!',description:'Reached level 200'},
            level_225:{title:'üëë Royal Achievement!',description:'Reached level 225'},
            level_250:{title:'üéØ Perfect Score!',description:'Completed all 250 levels!'},
            tier_easy:{title:'üü¢ Easy Tier Complete!',description:'Mastered the basics'},
            tier_medium:{title:'üü° Medium Tier Complete!',description:'Building skills'},
            tier_hard:{title:'üü† Hard Tier Complete!',description:'Getting challenging'},
            tier_expert:{title:'üî¥ Expert Tier Complete!',description:'Expert level achieved'},
            tier_legendary:{title:'üü£ Legendary Tier Complete!',description:'Legendary skills'},
            tier_master:{title:'‚ö´ Master Tier Complete!',description:'Master level reached'},
            tier_grandmaster:{title:'üîµ Grandmaster!',description:'Grandmaster achieved'},
            tier_ultimate:{title:'‚ö™ Ultimate Tier Complete!',description:'Ultimate mastery!'},
            score_5k:{title:'üí∞ 5K Points!',description:'Scored 5,000 points'},
            score_10k:{title:'üíé 10K Points!',description:'Scored 10,000 points'},
            score_25k:{title:'üèÖ 25K Points!',description:'Scored 25,000 points'},
            score_50k:{title:'ü•à 50K Points!',description:'Scored 50,000 points'},
            score_100k:{title:'ü•á 100K Points!',description:'Scored 100,000 points'},
        })[name];
    }

    showAchievementNotification(name) {
        const d = this.getAchievementData(name); if (!d) return;
        document.getElementById('achievementTitle').textContent       = d.title;
        document.getElementById('achievementDescription').textContent = d.description;
        const el = document.getElementById('achievementNotification');
        el.classList.add('show');
        setTimeout(() => el.classList.remove('show'), 4000);
        if (this.settings.haptic && navigator.vibrate) navigator.vibrate([200,100,200]);
    }

    showNotification(title, desc, duration=3000) {
        const el = document.createElement('div');
        el.className = 'achievement-notification';
        el.innerHTML = `<div class="achievement-title">${title}</div><div class="achievement-description">${desc}</div>`;
        document.body.appendChild(el);
        setTimeout(() => el.classList.add('show'), 100);
        setTimeout(() => { el.classList.remove('show'); setTimeout(()=>el.remove(),500); }, duration);
    }

    updateUI() {
        document.getElementById('level').textContent            = this.level;
        document.getElementById('score').textContent            = this.score;
        document.getElementById('bestScore').textContent        = this.bestScore;
        document.getElementById('achievementCount').textContent = this.achievements.length;
        document.getElementById('livesCount').textContent       = this.lives;
        const pct = Math.min((this.level/this.levelConfigs.length)*100,100);
        document.getElementById('progressLevel').textContent = Math.round(pct)+'%';
        document.getElementById('progressFill').style.width  = pct+'%';
    }

    updateDifficultyBadge(d) {
        const b = document.getElementById('difficultyBadge');
        b.className = `difficulty-badge difficulty-${d}`;
        b.textContent = d.toUpperCase();
    }

    showSettings() {
        document.getElementById('sensitivitySlider').value      = this.settings.sensitivity;
        document.getElementById('sensitivityValue').textContent = this.settings.sensitivity;
        document.getElementById('soundToggle').checked          = this.settings.sound;
        document.getElementById('hapticToggle').checked         = this.settings.haptic;
        document.getElementById('trailToggle').checked          = this.settings.trail;
        document.getElementById('autoPauseToggle').checked      = this.settings.autoPause;
        const sl = document.getElementById('sensitivitySlider');
        sl.oninput = () => document.getElementById('sensitivityValue').textContent = sl.value;
        document.getElementById('settingsModal').style.display = 'flex';
    }

    closeSettings() { document.getElementById('settingsModal').style.display='none'; }

    startTimer() {
        this.stopTimer();
        const cfg = this.getCurrentConfig();
        const timeLimits = { easy:40, medium:35, hard:28, expert:22, legendary:18, master:16, grandmaster:15, ultimate:14 };
        this.timeLeft = timeLimits[cfg.difficulty] || 30;
        this.updateTimerUI();
        this.timerRunning = true;
        this._timerInterval = setInterval(() => {
            if (!this.gameRunning || this.gamePaused || !this.timerRunning) return;
            this.timeLeft--;
            this.updateTimerUI();
            if (this.timeLeft <= 0) { this.stopTimer(); this.loseLife("Time's up!"); }
        }, 1000);
    }

    stopTimer() {
        if (this._timerInterval) { clearInterval(this._timerInterval); this._timerInterval = null; }
        this.timerRunning = false;
    }

    updateTimerUI() {
        const el = document.getElementById('timerCount');
        if (el) {
            el.textContent = this.timeLeft;
            el.style.color = this.timeLeft <= 5 ? '#f56565' : this.timeLeft <= 10 ? '#f6ad55' : '#fff';
        }
    }

    loseLife(reason) {
        this.lives = Math.max(0, this.lives - 1);
        this.combo = 0;
        document.getElementById('livesCount').textContent = this.lives;
        if (this.settings.haptic && navigator.vibrate) navigator.vibrate([200,100,200,100,400]);
        this.spawnParticles(this.ballX+10, this.ballY+10, '#f56565', 20);
        if (this.lives <= 0) { this.triggerGameOver(reason); }
        else {
            this.showNotification(`üíî Life lost! ‚Äî ${reason}`, `${this.lives} ${this.lives===1?'life':'lives'} remaining`, 2500);
            this.ballX = 165; this.ballY = 165; this.ballVelX = 0; this.ballVelY = 0;
            this.startTimer();
        }
    }

    triggerGameOver(reason) {
        this.gameRunning = false; this.levelCompleting = false;
        this.stopTimer(); this.gameOverActive = true;
        this.saveHighScore();
        document.getElementById('gameOverMsg').textContent   = reason;
        document.getElementById('gameOverScore').textContent = this.score;
        document.getElementById('gameOverLevel').textContent = this.level;
        document.getElementById('gameOverBest').textContent  = this.bestScore;
        document.getElementById('gameOverModal').style.display = 'flex';
        if (this.settings.haptic && navigator.vibrate) navigator.vibrate([400,100,400]);
    }

    restartGame() {
        document.getElementById('gameOverModal').style.display = 'none';
        this.gameOverActive = false;
        this.level = 1; this.score = 0; this.lives = 3; this.combo = 0;
        this.setupLevel(); this.updateUI(); this.startTimer();
        this.gameRunning = true;
        this.levelIntroLevel = this.level; this.levelIntroProgress = 0.001; this.levelIntroActive = true;
        this.tutorialActive = (this.level === 1); this.tutorialProgress = 0;
    }

    saveHighScore() {
        try {
            const scores = JSON.parse(localStorage.getItem('tiltSphereScores') || '[]');
            scores.push({ score: this.score, level: this.level, date: new Date().toLocaleDateString() });
            scores.sort((a,b) => b.score - a.score); scores.splice(5);
            localStorage.setItem('tiltSphereScores', JSON.stringify(scores));
            if (this.score > this.bestScore) { this.bestScore = this.score; localStorage.setItem('tiltSphereBest', this.bestScore.toString()); }
        } catch(e) {}
    }

    showLeaderboard() {
        const scores = JSON.parse(localStorage.getItem('tiltSphereScores') || '[]');
        const list   = document.getElementById('leaderboardList');
        if (!scores.length) { list.innerHTML = '<div style="opacity:.6">No scores yet ‚Äî play a game!</div>'; }
        else {
            const medals = ['ü•á','ü•à','ü•â','4Ô∏è‚É£','5Ô∏è‚É£'];
            list.innerHTML = scores.map((s,i) => `<div>${medals[i]} <b>${s.score.toLocaleString()}</b> pts &nbsp;¬∑&nbsp; Lvl ${s.level} &nbsp;¬∑&nbsp; <span style="opacity:.6">${s.date}</span></div>`).join('');
        }
        document.getElementById('leaderboardModal').style.display = 'flex';
    }

    closeLeaderboard() { document.getElementById('leaderboardModal').style.display = 'none'; }

    getComboMultiplier() {
        if (this.combo <= 0)  return 1;
        if (this.combo <= 2)  return 1.5;
        if (this.combo <= 5)  return 2;
        if (this.combo <= 9)  return 3;
        return 5;
    }

    showComboPopup(multiplier, x, y) {
        if (multiplier <= 1) return;
        const labels = { 1.5:'x1.5 COMBO!', 2:'x2 COMBO!', 3:'x3 HOT STREAK!', 5:'x5 ON FIRE! üî•' };
        this.scorePopups.push({ x, y: y - 35, text: labels[multiplier] || `x${multiplier}`, life: 80, maxLife: 80, color: multiplier >= 3 ? '#ffd700' : '#4fd1c7' });
    }

    drawJoystick(ctx) {
        const bx = this.joystickBase.x, by = this.joystickBase.y;
        const tx = this.joystickThumb.x, ty = this.joystickThumb.y;
        const active = this.joystickTouchId !== null;
        ctx.save();
        ctx.globalAlpha = active ? 0.75 : 0.35;
        ctx.strokeStyle = '#63b3ed'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(bx, by, 38, 0, Math.PI*2); ctx.stroke();
        ctx.strokeStyle = 'rgba(99,179,237,0.3)'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(bx, by, 20, 0, Math.PI*2); ctx.stroke();
        const tg = ctx.createRadialGradient(tx-3,ty-3,1,tx,ty,14);
        tg.addColorStop(0, '#fff'); tg.addColorStop(1, '#63b3ed');
        ctx.fillStyle = tg;
        ctx.beginPath(); ctx.arc(tx, ty, 14, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    }

    getBgTargetColour() {
        const cfg = this.getCurrentConfig();
        const themes = {
            easy:        { r:28, g:45, b:55  },
            medium:      { r:45, g:38, b:20  },
            hard:        { r:50, g:25, b:25  },
            expert:      { r:35, g:20, b:55  },
            legendary:   { r:55, g:45, b:10  },
            master:      { r:55, g:18, b:18  },
            grandmaster: { r:10, g:20, b:55  },
            ultimate:    { r:8,  g:8,  b:8   },
        };
        return themes[cfg.difficulty] || { r:28, g:36, b:48 };
    }

    drawTutorial(ctx) {
        const alpha = 1 - this.tutorialProgress;
        if (alpha <= 0) return;
        ctx.save();
        ctx.globalAlpha = alpha * 0.85;
        const arrowSize = 22;
        const cx = this.W/2, cy = this.H/2;
        const offsets = [
            { dx: 0,  dy:-55, angle: -Math.PI/2 },
            { dx: 0,  dy: 55, angle:  Math.PI/2 },
            { dx:-55, dy:  0, angle:  Math.PI    },
            { dx: 55, dy:  0, angle:  0          },
        ];
        const pulse = 0.7 + Math.sin(this.time * 4) * 0.3;
        offsets.forEach(o => {
            ctx.save();
            ctx.translate(cx + o.dx, cy + o.dy); ctx.rotate(o.angle); ctx.scale(pulse, pulse);
            ctx.fillStyle = '#63b3ed'; ctx.shadowColor = '#63b3ed'; ctx.shadowBlur = 12;
            ctx.beginPath(); ctx.moveTo(arrowSize, 0); ctx.lineTo(-arrowSize*0.6, arrowSize*0.6); ctx.lineTo(-arrowSize*0.6, -arrowSize*0.6); ctx.closePath(); ctx.fill();
            ctx.restore();
        });
        ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.shadowColor = '#000'; ctx.shadowBlur = 6;
        ctx.fillText('Tilt to move the ball', cx, cy + 80);
        ctx.restore();
    }

    getDailyDateString() {
        const d = new Date();
        return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    }

    getDailySeed(dateStr) {
        let h = 0;
        for (let i = 0; i < dateStr.length; i++) h = Math.imul(31, h) + dateStr.charCodeAt(i) | 0;
        return Math.abs(h);
    }

    startDailyChallenge() {
        if (!this.gameRunning) return;
        this.dailyDate  = this.getDailyDateString();
        this.dailySeed  = this.getDailySeed(this.dailyDate);
        const saved     = JSON.parse(localStorage.getItem('tiltSphereDailyScores') || '{}');
        const todayBest = saved[this.dailyDate];
        document.getElementById('dailyDateLabel').textContent = this.dailyDate;
        document.getElementById('dailyBestScore').textContent = todayBest
            ? `Your best today: ${todayBest.score} pts (level ${todayBest.level})`
            : 'No score yet today ‚Äî go for it!';
        document.getElementById('dailyModal').style.display = 'flex';
    }

    closeDailyModal() { document.getElementById('dailyModal').style.display = 'none'; }

    confirmDailyChallenge() {
        this.closeDailyModal();
        this.gameMode = 'daily'; this.level = 1; this.score = 0; this.lives = 3; this.combo = 0;
        this._rng = this._seededRng(this.dailySeed);
        this.setupLevel(); this.updateUI(); this.startTimer();
        this.levelIntroLevel = 1; this.levelIntroProgress = 0.001; this.levelIntroActive = true;
        this.showNotification('üìÖ Daily Challenge!', `Seed: ${this.dailyDate}`, 2500);
    }

    saveDailyScore() {
        try {
            const saved = JSON.parse(localStorage.getItem('tiltSphereDailyScores') || '{}');
            const prev  = saved[this.dailyDate];
            if (!prev || this.score > prev.score) {
                saved[this.dailyDate] = { score: this.score, level: this.level };
                localStorage.setItem('tiltSphereDailyScores', JSON.stringify(saved));
            }
        } catch(e) {}
    }

    _seededRng(seed) {
        let s = seed >>> 0;
        return () => {
            s += 0x6D2B79F5;
            let t = Math.imul(s ^ (s >>> 15), 1 | s);
            t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
            return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
    }

    startEndlessMode() {
        if (!this.gameRunning) return;
        this.gameMode = 'endless'; this.endlessLevel = 1; this.level = 1; this.score = 0; this.lives = 3; this.combo = 0;
        this.setupLevel(); this.updateUI(); this.startTimer();
        this.levelIntroLevel = 1; this.levelIntroProgress = 0.001; this.levelIntroActive = true;
        this.showNotification('‚ôæÔ∏è Endless Mode!', 'How far can you go?', 2500);
    }

    getEndlessConfig() {
        const n = this.endlessLevel;
        return {
            funnelSize:      Math.max(30 - Math.floor(n/20), 18),
            obstacles:       Math.min(8 + Math.floor(n/3), 50),
            movingObstacles: Math.min(3 + Math.floor(n/5), 20),
            ballSpeed:       Math.min(1.5 + n * 0.015, 4),
            difficulty:      n < 10 ? 'hard' : n < 25 ? 'expert' : n < 50 ? 'legendary' : n < 100 ? 'master' : 'ultimate',
            specialMechanic: 'endless'
        };
    }

    saveEndlessScore() {
        try {
            const scores = JSON.parse(localStorage.getItem('tiltSphereEndlessScores') || '[]');
            scores.push({ score: this.score, level: this.endlessLevel, date: new Date().toLocaleDateString() });
            scores.sort((a,b) => b.score - a.score); scores.splice(5);
            localStorage.setItem('tiltSphereEndlessScores', JSON.stringify(scores));
        } catch(e) {}
    }

    getSkinDefs() {
        return [
            { id:0, name:'Classic',  color:'#fc8181', unlockAchievement:null,            emoji:'üî¥' },
            { id:1, name:'Ocean',    color:'#63b3ed', unlockAchievement:'tier_easy',      emoji:'üîµ' },
            { id:2, name:'Forest',   color:'#68d391', unlockAchievement:'tier_hard',      emoji:'üü¢' },
            { id:3, name:'Gold',     color:'#ffd700', unlockAchievement:'tier_legendary', emoji:'üü°' },
            { id:4, name:'Plasma',   color:'#b794f4', unlockAchievement:'tier_master',    emoji:'üü£' },
        ];
    }

    showSkinPicker() {
        const grid  = document.getElementById('skinGrid');
        const skins = this.getSkinDefs();
        grid.innerHTML = skins.map(s => {
            const unlocked = s.unlockAchievement === null || this.achievements.includes(s.unlockAchievement);
            const active   = this.activeSkin === s.id;
            return `<div onclick="game.selectSkin(${s.id})" style="cursor:${unlocked?'pointer':'default'};padding:10px 6px;border-radius:10px;text-align:center;border:2px solid ${active?'#ffd700':'rgba(255,255,255,0.15)'};background:${active?'rgba(255,215,0,0.1)':'rgba(255,255,255,0.04)'};opacity:${unlocked?1:0.4};">
                <div style="font-size:24px">${s.emoji}</div>
                <div style="font-size:10px;margin-top:4px">${s.name}</div>
                <div style="font-size:9px;opacity:.6">${unlocked?'‚úì Unlocked':'Locked'}</div>
            </div>`;
        }).join('');
        document.getElementById('skinModal').style.display = 'flex';
    }

    selectSkin(id) {
        const skins   = this.getSkinDefs();
        const skin    = skins.find(s => s.id === id);
        if (!skin) return;
        const unlocked = skin.unlockAchievement === null || this.achievements.includes(skin.unlockAchievement);
        if (!unlocked) { this.showNotification('üîí Locked', `Earn the ${skin.unlockAchievement} achievement`, 2500); return; }
        this.activeSkin = id;
        try { localStorage.setItem('tiltSphereSkin', id.toString()); } catch(e) {}
        this.showSkinPicker();
    }

    closeSkinPicker() { document.getElementById('skinModal').style.display = 'none'; }

    saveSettings() {
        this.settings.sensitivity = parseInt(document.getElementById('sensitivitySlider').value);
        this.settings.sound       = document.getElementById('soundToggle').checked;
        this.settings.haptic      = document.getElementById('hapticToggle').checked;
        this.settings.trail       = document.getElementById('trailToggle').checked;
        this.settings.autoPause   = document.getElementById('autoPauseToggle').checked;
        try {
            localStorage.setItem('tiltSphereSettings', JSON.stringify(this.settings));
            this.closeSettings();
            document.getElementById('saveStatus').textContent='Settings saved!';
            setTimeout(()=>{ if(document.getElementById('saveStatus').textContent.includes('Settings saved!')) document.getElementById('saveStatus').textContent=''; },3000);
        } catch(e) { alert('Failed to save settings.'); }
    }
}

let game;
document.addEventListener('DOMContentLoaded', () => {
    try {
        game = new TiltBallGame();
    } catch(e) {
        console.error(e);
        document.body.innerHTML = `<div style="color:#fff;text-align:center;padding:50px"><h2>Game Failed to Load</h2><p>Please refresh.</p><p style="font-size:12px;margin-top:20px">Error: ${e.message}</p></div>`;
    }
});
</script>
</body>
</html>
