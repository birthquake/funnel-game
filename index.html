<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>TiltSphere - Ultimate Ball Challenge</title>
    <!-- PWA -->
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#0f0f23">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TiltSphere">
    <link rel="apple-touch-icon" href="/icon-192.png">
    <!-- SEO / OG -->
    <meta name="description" content="Tilt your phone to guide the ball into the target. 250 levels of increasingly devious challenges.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

```
    html { height: 100%; overflow: hidden; }

    body {
        background: linear-gradient(135deg, #0f0f23, #1a1a2e, #16213e, #0f3460);
        background-size: 400% 400%;
        animation: gradientShift 15s ease infinite;
        font-family: 'Arial', sans-serif;
        color: #fff;
        overflow: hidden;
        position: fixed;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }

    @keyframes gradientShift {
        0%   { background-position: 0% 50%; }
        50%  { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }

    /* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
    .header { text-align: center; margin-bottom: 10px; z-index: 50; }

    .title {
        font-size: 28px; font-weight: bold;
        text-shadow: 0 0 20px rgba(99,179,237,.8);
        margin-bottom: 5px;
        background: linear-gradient(45deg, #63b3ed, #4fd1c7, #68d391);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }

    .stats {
        display: flex; gap: 15px; font-size: 14px;
        margin-bottom: 8px; flex-wrap: wrap; justify-content: center;
    }

    .stat-item {
        padding: 3px 8px;
        background: rgba(99,179,237,.1);
        border-radius: 10px;
        border: 1px solid rgba(99,179,237,.3);
    }

    .progress-meter {
        width: 200px; height: 12px; background: #333;
        border: 1px solid #63b3ed; margin: 10px auto;
        border-radius: 6px; overflow: hidden;
    }

    .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #68d391, #4fd1c7, #63b3ed);
        width: 0%; transition: width .5s ease;
    }

    /* ‚îÄ‚îÄ Difficulty badges ‚îÄ‚îÄ */
    .difficulty-badge { display:inline-block; padding:2px 8px; border-radius:10px; font-size:10px; margin-left:8px; }
    .difficulty-easy        { background:#68d391; color:#000; }
    .difficulty-medium      { background:#f6ad55; color:#000; }
    .difficulty-hard        { background:#f56565; color:#fff; }
    .difficulty-expert      { background:#9f7aea; color:#fff; }
    .difficulty-legendary   { background:#ffd700; color:#000; }
    .difficulty-master      { background:#e53e3e; color:#fff; }
    .difficulty-grandmaster { background:#1a365d; color:#fff; }
    .difficulty-ultimate    { background:#000;    color:#ffd700; }

    /* ‚îÄ‚îÄ Canvas wrapper ‚îÄ‚îÄ */
    .game-container {
        position: relative;
        width: 350px; height: 350px;
        border: 3px solid #63b3ed;
        border-radius: 20px;
        box-shadow: 0 0 30px rgba(99,179,237,.4), inset 0 0 30px rgba(99,179,237,.1);
        overflow: hidden;
    }

    canvas {
        display: block;
        width: 350px; height: 350px;
        border-radius: 17px;
    }

    /* ‚îÄ‚îÄ Save indicator (overlaid on canvas) ‚îÄ‚îÄ */
    .save-indicator {
        position: absolute; top: 10px; right: 10px;
        background: rgba(104,211,145,.2); border: 1px solid #68d391;
        padding: 5px 10px; border-radius: 15px; font-size: 10px;
        color: #68d391; opacity: 0; transition: opacity .3s ease;
        pointer-events: none;
    }
    .save-indicator.show { opacity: 1; }

    /* ‚îÄ‚îÄ Pause overlay (overlaid on canvas) ‚îÄ‚îÄ */
    .paused-overlay {
        position: absolute; inset: 0;
        background: rgba(0,0,0,.8);
        display: flex; align-items: center; justify-content: center;
        z-index: 150; opacity: 0; pointer-events: none;
        transition: opacity .3s ease; border-radius: 17px;
    }
    .paused-overlay.show { opacity: 1; pointer-events: all; }
    .paused-content { text-align: center; color: #fff; }
    .paused-content h2 { font-size: 24px; margin-bottom: 10px; color: #63b3ed; }

    /* ‚îÄ‚îÄ Achievement toast ‚îÄ‚îÄ */
    .achievement-notification {
        position: fixed; top: 20px; right: -400px;
        background: linear-gradient(45deg, #ffd700, #ffed4e);
        color: #000; padding: 15px 20px; border-radius: 10px;
        border: 2px solid #ffd700; font-weight: bold;
        z-index: 200; transition: right .5s ease; max-width: 300px;
        box-shadow: 0 4px 20px rgba(255,215,0,.4);
    }
    .achievement-notification.show { right: 20px; }
    .achievement-title       { font-size: 16px; margin-bottom: 5px; }
    .achievement-description { font-size: 12px; opacity: .8; }

    /* ‚îÄ‚îÄ Controls ‚îÄ‚îÄ */
    .controls {
        text-align: center; margin-top: 15px;
        font-size: 12px; max-width: 350px; z-index: 50;
    }

    .start-button, .menu-button {
        background: linear-gradient(45deg, #63b3ed, #4fd1c7);
        border: none; color: #fff; padding: 12px 24px;
        font-family: inherit; cursor: pointer; margin: 8px;
        border-radius: 8px; font-size: 14px; font-weight: bold;
        box-shadow: 0 4px 15px rgba(99,179,237,.3);
        transition: all .3s ease;
    }
    .start-button:hover, .menu-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(99,179,237,.4);
    }
    .menu-button {
        font-size: 12px; padding: 8px 16px;
        background: linear-gradient(45deg, #4a5568, #63b3ed);
    }
    .menu-buttons {
        display: flex; gap: 10px; margin-top: 10px;
        flex-wrap: wrap; justify-content: center;
    }

    .skip-level-hint {
        font-size: 10px; color: #f6ad55; margin-top: 5px;
        opacity: 0; transition: opacity .3s ease;
    }
    .skip-level-hint.show { opacity: 1; }

    /* ‚îÄ‚îÄ Orientation lock overlay ‚îÄ‚îÄ */
    .orientation-overlay {
        display: none;
        position: fixed; inset: 0; z-index: 9999;
        background: #0f0f23;
        flex-direction: column; align-items: center; justify-content: center;
        color: #fff; text-align: center; padding: 30px;
    }
    .orientation-overlay.show { display: flex; }
    .rotate-icon {
        font-size: 64px; margin-bottom: 20px;
        animation: rotateHint 2s ease-in-out infinite;
    }
    @keyframes rotateHint {
        0%,100% { transform: rotate(0deg); }
        50%      { transform: rotate(90deg); }
    }

    /* ‚îÄ‚îÄ Splash screen ‚îÄ‚îÄ */
    .splash-screen {
        position: fixed; inset: 0; z-index: 10000;
        background: #0f0f23;
        display: flex; flex-direction: column;
        align-items: center; justify-content: center;
        transition: opacity 0.6s ease;
    }
    .splash-screen.fade-out { opacity: 0; pointer-events: none; }
    .splash-title {
        font-size: 42px; font-weight: bold; letter-spacing: 4px;
        background: linear-gradient(45deg, #63b3ed, #4fd1c7, #68d391);
        -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        background-clip: text;
        animation: splashPulse 1.5s ease-in-out infinite;
    }
    .splash-sub {
        font-size: 13px; color: rgba(255,255,255,0.5);
        margin-top: 12px; letter-spacing: 2px;
    }
    .splash-ball {
        width: 40px; height: 40px; border-radius: 50%;
        background: radial-gradient(circle at 35% 35%, #fff, #fc8181, #c53030);
        margin-bottom: 30px;
        box-shadow: 0 0 30px rgba(245,101,101,0.6);
        animation: splashBounce 1s ease-in-out infinite;
    }
    @keyframes splashPulse {
        0%,100% { opacity: 1; } 50% { opacity: 0.7; }
    }
    @keyframes splashBounce {
        0%,100% { transform: translateY(0); }
        50%      { transform: translateY(-18px); }
    }

    /* ‚îÄ‚îÄ Emergency center button (overlaid bottom-left of canvas) ‚îÄ‚îÄ */
    .emergency-center {
        position: absolute; bottom: 10px; left: 10px;
        background: rgba(245,101,101,0.15);
        border: 1px solid rgba(245,101,101,0.6);
        color: #fc8181; padding: 6px 12px;
        border-radius: 20px; font-size: 10px; font-weight: bold;
        cursor: pointer; opacity: 0; pointer-events: none;
        transition: opacity .4s ease, background .2s ease;
        z-index: 10; user-select: none; -webkit-user-select: none;
        letter-spacing: 0.3px;
    }
    .emergency-center.show   { opacity: 1; pointer-events: all; }
    .emergency-center:active { background: rgba(245,101,101,0.35); }
</style>
```

</head>
<body>

<!-- ‚îÄ‚îÄ Splash screen ‚îÄ‚îÄ -->

<div class="splash-screen" id="splashScreen">
    <div class="splash-ball"></div>
    <div class="splash-title">TILTSPHERE</div>
    <div class="splash-sub">ULTIMATE BALL CHALLENGE</div>
</div>

<!-- ‚îÄ‚îÄ Orientation lock ‚îÄ‚îÄ -->

<div class="orientation-overlay" id="orientationOverlay">
    <div class="rotate-icon">üì±</div>
    <div style="font-size:18px;font-weight:bold;margin-bottom:10px">Please rotate your device</div>
    <div style="font-size:13px;opacity:.7">TiltSphere is designed for portrait mode</div>
</div>

<!-- ‚îÄ‚îÄ Header ‚îÄ‚îÄ -->

<div class="header">
    <div class="title">TILTSPHERE</div>
    <div class="stats">
        <div class="stat-item">Level: <span id="level">1</span><span id="difficultyBadge" class="difficulty-badge difficulty-easy">EASY</span></div>
        <div class="stat-item">Score: <span id="score">0</span></div>
        <div class="stat-item">Best: <span id="bestScore">0</span></div>
        <div class="stat-item" id="livesDisplay">‚ù§Ô∏è <span id="livesCount">3</span></div>
        <div class="stat-item" id="timerDisplay">‚è± <span id="timerCount">--</span></div>
    </div>
    <div class="progress-meter"><div class="progress-fill" id="progressFill"></div></div>
    <div style="font-size:10px">Progress: <span id="progressLevel">0%</span> ‚Ä¢ <span id="achievementCount">0</span> achievements</div>
</div>

<!-- ‚îÄ‚îÄ Achievement toast ‚îÄ‚îÄ -->

<div class="achievement-notification" id="achievementNotification">
    <div class="achievement-title"       id="achievementTitle"></div>
    <div class="achievement-description" id="achievementDescription"></div>
</div>

<!-- ‚îÄ‚îÄ Game canvas ‚îÄ‚îÄ -->

<div class="game-container" id="gameContainer">
    <canvas id="gameCanvas" width="350" height="350"></canvas>
    <div class="save-indicator" id="saveIndicator">Progress Saved!</div>
    <div class="paused-overlay" id="pausedOverlay">
        <div class="paused-content">
            <h2>PAUSED</h2>
            <p id="pauseMsg">Tap anywhere to resume</p>
        </div>
    </div>
    <!-- Emergency centre: appears after ball is stuck 5 seconds, double-tap to reset -->
    <div class="emergency-center" id="emergencyCenter">‚äï Double-tap to centre</div>
</div>

<!-- ‚îÄ‚îÄ Controls ‚îÄ‚îÄ -->

<div class="controls">
    <button class="start-button" id="startButton">START GAME</button>
    <div class="menu-buttons" id="menuButtons" style="display:none">
        <button class="menu-button" onclick="game.pauseGame()">Pause</button>
        <button class="menu-button" onclick="game.saveGame()">Save</button>
        <button class="menu-button" onclick="game.showSettings()">Settings</button>
        <button class="menu-button" onclick="game.resetProgress()">Reset</button>
        <button class="menu-button" id="skipButton" onclick="game.skipLevel()" style="display:none">Skip Level</button>
        <button class="menu-button" onclick="game.showLeaderboard()">Scores</button>
        <button class="menu-button" onclick="game.showSkinPicker()">Skins</button>
        <button class="menu-button" onclick="game.startDailyChallenge()">Daily</button>
        <button class="menu-button" onclick="game.startEndlessMode()">Endless</button>
    </div>
    <div>Tilt your device to guide the ball into the target</div>
    <div class="skip-level-hint" id="skipLevelHint">Having trouble? Skip available after 10 attempts</div>
    <div style="margin-top:5px;font-size:10px" id="saveStatus"></div>
</div>

<!-- ‚îÄ‚îÄ Leaderboard modal ‚îÄ‚îÄ -->

<div id="leaderboardModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.85);z-index:100;align-items:center;justify-content:center">
    <div style="background:linear-gradient(135deg,#1a202c,#2d3748);border:2px solid #ffd700;border-radius:15px;padding:20px;width:90%;max-width:300px;color:#fff;text-align:center">
        <h3 style="color:#ffd700;margin-bottom:15px">üèÜ High Scores</h3>
        <div id="leaderboardList" style="margin-bottom:20px;font-size:13px;line-height:2"></div>
        <button onclick="game.closeLeaderboard()" style="background:#ffd700;color:#000;border:none;padding:8px 20px;border-radius:5px;cursor:pointer;font-weight:bold">Close</button>
    </div>
</div>

<!-- ‚îÄ‚îÄ Game Over modal ‚îÄ‚îÄ -->

<div id="gameOverModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.9);z-index:200;align-items:center;justify-content:center">
    <div style="background:linear-gradient(135deg,#1a202c,#2d3748);border:2px solid #f56565;border-radius:15px;padding:25px;width:90%;max-width:300px;color:#fff;text-align:center">
        <h2 style="color:#f56565;margin-bottom:8px">GAME OVER</h2>
        <p id="gameOverMsg" style="font-size:13px;margin-bottom:15px;opacity:.8"></p>
        <div style="font-size:22px;font-weight:bold;color:#ffd700;margin-bottom:5px">Score: <span id="gameOverScore">0</span></div>
        <div style="font-size:13px;margin-bottom:5px">Level reached: <span id="gameOverLevel">1</span></div>
        <div style="font-size:13px;margin-bottom:20px">Best: <span id="gameOverBest">0</span></div>
        <div style="display:flex;gap:10px;justify-content:center">
            <button onclick="game.restartGame()" style="background:#68d391;color:#000;border:none;padding:10px 18px;border-radius:8px;cursor:pointer;font-weight:bold">Play Again</button>
            <button onclick="game.showLeaderboard()" style="background:#ffd700;color:#000;border:none;padding:10px 18px;border-radius:8px;cursor:pointer;font-weight:bold">Scores</button>
        </div>
    </div>
</div>

<!-- ‚îÄ‚îÄ Skin Picker modal ‚îÄ‚îÄ -->

<div id="skinModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.85);z-index:100;align-items:center;justify-content:center">
    <div style="background:linear-gradient(135deg,#1a202c,#2d3748);border:2px solid #63b3ed;border-radius:15px;padding:20px;width:90%;max-width:300px;color:#fff;text-align:center">
        <h3 style="color:#63b3ed;margin-bottom:5px">üé® Ball Skins</h3>
        <p style="font-size:11px;opacity:.6;margin-bottom:15px">Unlock skins by earning achievements</p>
        <div id="skinGrid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-bottom:18px"></div>
        <button onclick="game.closeSkinPicker()" style="background:#63b3ed;color:#000;border:none;padding:8px 20px;border-radius:5px;cursor:pointer;font-weight:bold">Close</button>
    </div>
</div>

<!-- ‚îÄ‚îÄ Daily Challenge modal ‚îÄ‚îÄ -->

<div id="dailyModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.85);z-index:100;align-items:center;justify-content:center">
    <div style="background:linear-gradient(135deg,#1a202c,#2d3748);border:2px solid #68d391;border-radius:15px;padding:22px;width:90%;max-width:300px;color:#fff;text-align:center">
        <h3 style="color:#68d391;margin-bottom:5px">üìÖ Daily Challenge</h3>
        <p style="font-size:12px;opacity:.7;margin-bottom:4px">Same level layout for everyone today</p>
        <p id="dailyDateLabel" style="font-size:11px;color:#68d391;margin-bottom:15px"></p>
        <div id="dailyBestScore" style="font-size:13px;margin-bottom:15px;opacity:.8"></div>
        <div style="display:flex;gap:10px;justify-content:center">
            <button onclick="game.confirmDailyChallenge()" style="background:#68d391;color:#000;border:none;padding:10px 18px;border-radius:8px;cursor:pointer;font-weight:bold">Play!</button>
            <button onclick="game.closeDailyModal()" style="background:#4a5568;color:#fff;border:none;padding:10px 18px;border-radius:8px;cursor:pointer">Cancel</button>
        </div>
    </div>
</div>

<!-- ‚îÄ‚îÄ Endless mode ‚îÄ‚îÄ no extra modal needed, just starts -->

<!-- ‚îÄ‚îÄ Settings modal ‚îÄ‚îÄ -->

<div id="settingsModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.8);z-index:100;align-items:center;justify-content:center">
    <div style="background:linear-gradient(135deg,#1a202c,#2d3748);border:2px solid #63b3ed;border-radius:15px;padding:20px;width:90%;max-width:300px;color:#fff">
        <h3 style="text-align:center;margin-bottom:20px;color:#63b3ed">Settings</h3>
        <div style="margin-bottom:15px">
            <label style="display:block;margin-bottom:5px">Sensitivity: <span id="sensitivityValue">50</span>%</label>
            <input type="range" id="sensitivitySlider" min="10" max="100" value="50" style="width:100%">
        </div>
        <div style="margin-bottom:15px">
            <label style="display:flex;align-items:center;gap:10px"><input type="checkbox" id="soundToggle" checked><span>Sound Effects</span></label>
        </div>
        <div style="margin-bottom:15px">
            <label style="display:flex;align-items:center;gap:10px"><input type="checkbox" id="hapticToggle" checked><span>Haptic Feedback</span></label>
        </div>
        <div style="margin-bottom:15px">
            <label style="display:flex;align-items:center;gap:10px"><input type="checkbox" id="trailToggle" checked><span>Ball Trail</span></label>
        </div>
        <div style="margin-bottom:20px">
            <label style="display:flex;align-items:center;gap:10px"><input type="checkbox" id="autoPauseToggle" checked><span>Auto-pause when window loses focus</span></label>
        </div>
        <div style="display:flex;gap:10px;justify-content:center">
            <button onclick="game.saveSettings()" style="background:#68d391;color:#000;border:none;padding:8px 16px;border-radius:5px;cursor:pointer">Save</button>
            <button onclick="game.closeSettings()" style="background:#f56565;color:#fff;border:none;padding:8px 16px;border-radius:5px;cursor:pointer">Cancel</button>
        </div>
    </div>
</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  TiltSphere ‚Äî Canvas Edition
//  All game logic is identical to the DOM version.
//  Only the rendering layer has been replaced with Canvas 2D.
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class TiltBallGame {
    constructor() {
        // ‚îÄ‚îÄ Canvas setup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.canvas = document.getElementById('gameCanvas');
        this.ctx    = this.canvas.getContext('2d');

        // ‚îÄ‚îÄ DOM refs (UI only ‚Äî nothing rendered as DOM elements now) ‚îÄ‚îÄ
        this.startButton          = document.getElementById('startButton');
        this.pausedOverlay        = document.getElementById('pausedOverlay');
        this.achievementNotification = document.getElementById('achievementNotification');

        // ‚îÄ‚îÄ Physics ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.ballX    = 165;  this.ballY    = 165;
        this.ballVelX = 0;    this.ballVelY = 0;
        this.friction    = 0.95;
        this.sensitivity = 0.5;
        this.maxVelocity = 8;
        this.ballSize    = 20;  // radius = 10

        // ‚îÄ‚îÄ Game state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.level         = 1;
        this.score         = 0;
        this.bestScore     = parseInt(localStorage.getItem('tiltSphereBest') || '0');
        this.gameRunning   = false;
        this.gamePaused    = false;
        this.levelCompleting = false;
        this.levelAttempts = 0;
        this.stuckTimer    = 0;
        this.lastBallPos   = { x: 165, y: 165 };

        // ‚îÄ‚îÄ Lives & failure ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.lives         = 3;
        this.timeLeft      = 30;      // seconds, set per level
        this.timerRunning  = false;
        this._timerInterval = null;
        this.gameOverActive = false;

        // ‚îÄ‚îÄ Combo multiplier ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.combo         = 0;       // consecutive clean levels (no obstacle hits)
        this.levelHitCount = 0;       // obstacle hits this level
        this._comboPopup   = null;    // { text, life, maxLife, x, y }

        // ‚îÄ‚îÄ Game mode ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.gameMode      = 'normal';  // 'normal' | 'daily' | 'endless'
        this.endlessLevel  = 1;         // endless mode counter
        this.dailyDate     = '';
        this.dailySeed     = 0;

        // ‚îÄ‚îÄ Ball skin ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // 0=classic(red), 1=ocean(blue), 2=forest(green), 3=gold, 4=plasma(purple)
        this.activeSkin    = parseInt(localStorage.getItem('tiltSphereSkin') || '0');

        // ‚îÄ‚îÄ Splash ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.splashDone    = false;

        // ‚îÄ‚îÄ Virtual joystick ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.joystickActive   = false;  // shown when no gyro available
        this.joystickBase     = { x: 60, y: 290 };
        this.joystickThumb    = { x: 60, y: 290 };
        this.joystickTouchId  = null;
        this.gyroAvailable    = false;

        // ‚îÄ‚îÄ Tilt calibration ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.tiltOffsetBeta  = 0;
        this.tiltOffsetGamma = 0;
        this.calibrating     = false;
        this.calibrationSamples = [];
        this.calibrationDone = false;

        // ‚îÄ‚îÄ Tutorial (level 1 only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.tutorialActive  = false;
        this.tutorialProgress = 0;    // 0..1

        // ‚îÄ‚îÄ Background theme ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.bgTheme = { r:45, g:55, b:72 }; // current arena bg colour (interpolated)

        // ‚îÄ‚îÄ Obstacles (pure data, no DOM elements) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Each: { x, y, w, h, isMoving, dir, speed, range, startX, startY, phase }
        this.obstacles = [];

        // ‚îÄ‚îÄ Visual trail (array of {x,y,alpha}) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.trail = [];

        // ‚îÄ‚îÄ Canvas particles ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Each: { x, y, vx, vy, life, maxLife, color, size }
        this.particles = [];

        // ‚îÄ‚îÄ Shockwave rings (level-complete effect) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Each: { x, y, radius, maxRadius, life, maxLife }
        this.shockwaves = [];

        // ‚îÄ‚îÄ Score popups ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Each: { x, y, text, life, maxLife }
        this.scorePopups = [];

        // ‚îÄ‚îÄ Near-miss proximity (0=far away, 1=ball touching edge of funnel) ‚îÄ‚îÄ‚îÄ
        this.nearMissProximity = 0;

        // ‚îÄ‚îÄ Emergency centre button ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.emergencyCenter = document.getElementById('emergencyCenter');
        this._ecTapCount = 0;
        this._ecTapTimer = null;

        // ‚îÄ‚îÄ Web Audio sound engine ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.audioCtx = null;  // created lazily on first user gesture
        this._nearMissSoundActive = false;

        // ‚îÄ‚îÄ Achievements ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.achievements = JSON.parse(localStorage.getItem('tiltSphereAchievements') || '[]');

        // ‚îÄ‚îÄ Settings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.settings = { sound:true, haptic:true, trail:true, sensitivity:50, autoPause:true };
        try {
            const s = localStorage.getItem('tiltSphereSettings');
            if (s) this.settings = { ...this.settings, ...JSON.parse(s) };
        } catch(e) { console.warn('Settings load failed', e); }

        // ‚îÄ‚îÄ Arena size ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.W = 350;
        this.H = 350;

        // ‚îÄ‚îÄ Funnel position (set in setupLevel) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.funnelX = 280; this.funnelY = 280;
        this.funnelPulsePhase = 0;

        // ‚îÄ‚îÄ Level intro animation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // levelIntroProgress: 0=not running, >0=animating (0..1 then done)
        this.levelIntroProgress  = 0;
        this.levelIntroActive    = false;
        this.levelIntroLevel     = 1;

        // ‚îÄ‚îÄ Animation time (for moving obstacle phase) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.time = 0;

        // ‚îÄ‚îÄ Level configs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.levelConfigs = this.generateLevelConfigs();

        // ‚îÄ‚îÄ Init ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.loadGame();
        this.setupLevel();
        this.updateUI();
        this.setupEventListeners();
        this.setupAutoPause();

        // Detect gyro
        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', (e) => {
                if (e.gamma !== null || e.beta !== null) this.gyroAvailable = true;
            }, { once: true });
        }

        // Splash is dismissed from outside the constructor (see boot section)
        // so it always fires even if init throws

        // Orientation lock
        this.setupOrientationLock();

        // Start render loop even before game starts (draws idle state)
        this.renderLoop();
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  LEVEL CONFIG GENERATION (unchanged from DOM version)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    generateLevelConfigs() {
        const c = [];
        for (let i = 1;   i <= 20;  i++) c.push({ funnelSize: Math.max(60-i*2,35),   obstacles: Math.min(2+Math.floor(i/3),6),          movingObstacles: 0,                              ballSpeed: 1+(i*.02),              difficulty:'easy',        specialMechanic:null });
        for (let i = 21;  i <= 40;  i++) c.push({ funnelSize: Math.max(35-(i-20)*.25,30), obstacles: Math.min(2+Math.floor((i-20)/3),6), movingObstacles: Math.min(Math.floor((i-25)/3),2), ballSpeed: 1.2+((i-20)*.03),      difficulty:'medium',      specialMechanic: i%8===0?'rotating':null });
        for (let i = 41;  i <= 60;  i++) c.push({ funnelSize: 30,                     obstacles: Math.min(4+Math.floor((i-40)/2),10),    movingObstacles: Math.min(Math.floor((i-40)/3),4), ballSpeed: 1.4+((i-40)*.04),      difficulty:'hard',        specialMechanic:['rotating','bouncy'][Math.floor((i-40)/10)%2] });
        for (let i = 61;  i <= 80;  i++) c.push({ funnelSize: 30,                     obstacles: Math.min(6+Math.floor((i-60)/2),15),    movingObstacles: Math.min(3+Math.floor((i-60)/3),6), ballSpeed: 1.6+((i-60)*.05),   difficulty:'expert',      specialMechanic:['maze','spiral'][Math.floor((i-60)/10)%2] });
        for (let i = 81;  i <= 100; i++) c.push({ funnelSize: 30,                     obstacles: Math.min(10+Math.floor((i-80)/2),20),   movingObstacles: Math.min(4+Math.floor((i-80)/2),8), ballSpeed: 1.8+((i-80)*.06),   difficulty:'legendary',   specialMechanic:['ultimate','chaos'][Math.floor((i-80)/10)%2] });
        for (let i = 101; i <= 250; i++) {
            const tier = Math.floor((i-101)/50);
            c.push({ funnelSize: 30, obstacles: Math.min(12+Math.floor((i-100)/5),35), movingObstacles: Math.min(5+Math.floor((i-100)/10),15), ballSpeed: 2.0+((i-100)*.02), difficulty: ['master','grandmaster','ultimate'][Math.min(tier,2)], specialMechanic:['master_challenge','ultimate_precision','chaos_mode'][tier%3] });
        }
        return c;
    }

    getCurrentConfig() {
        if (this.gameMode === 'endless') return this.getEndlessConfig();
        return this.levelConfigs[Math.min(this.level-1, this.levelConfigs.length-1)];
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  LEVEL SETUP
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    setupLevel() {
        this.obstacles  = [];
        this.trail      = [];
        this.particles  = [];
        this.shockwaves = [];
        this.scorePopups = [];

        const cfg = this.getCurrentConfig();
        const fs  = Math.max(cfg.funnelSize, 30);

        // Place funnel at least 120px from ball start (centre)
        const margin = Math.max(fs + 20, 30);
        let placed = false;
        for (let a = 0; a < 50; a++) {
            this.funnelX = margin + Math.random() * (this.W - 2*margin - fs);
            this.funnelY = margin + Math.random() * (this.H - 2*margin - fs);
            const cx = this.funnelX + fs/2, cy = this.funnelY + fs/2;
            if (Math.hypot(cx-165, cy-165) >= 120) { placed = true; break; }
        }
        if (!placed) {
            const fb = [
                { x: this.W-fs-40, y: 40 }, { x: 40, y: this.H-fs-40 },
                { x: this.W-fs-40, y: this.H-fs-40 }, { x: 40, y: 40 }
            ];
            const f = fb[Math.floor(Math.random()*fb.length)];
            this.funnelX = f.x; this.funnelY = f.y;
        }

        // Place obstacles
        for (let i = 0; i < cfg.obstacles;       i++) this.spawnObstacle(false, cfg);
        for (let i = 0; i < cfg.movingObstacles; i++) this.spawnObstacle(true,  cfg);

        // Reset ball
        this.ballX = 165; this.ballY = 165;
        this.ballVelX = 0; this.ballVelY = 0;
        this.levelAttempts = 0;
        this.stuckTimer    = 0;

        document.getElementById('skipLevelHint').classList.remove('show');
        document.getElementById('skipButton').style.display = 'none';

        this.updateDifficultyBadge(cfg.difficulty);

        // Reset per-level state
        this.levelHitCount = 0;

        // Trigger level intro animation (only when game is already running)
        if (this.gameRunning) {
            this.levelIntroLevel    = this.level;
            this.levelIntroProgress = 0.001;
            this.levelIntroActive   = true;
            this.startTimer();
        }

        // Tutorial on level 1
        if (this.level === 1 && this.gameRunning) {
            this.tutorialActive   = true;
            this.tutorialProgress = 0;
        }
    }

    spawnObstacle(isMoving, cfg) {
        const fs   = Math.max(cfg.funnelSize, 30);
        const size = 20 + Math.random() * 15;
        let x, y, valid = false;

        for (let a = 0; a < 100; a++) {
            const fcx = this.funnelX + fs/2, fcy = this.funnelY + fs/2;
            const pp  = Math.random();
            const pv  = (Math.random()-.5) * 120;
            const pa  = Math.atan2(fcy-165, fcx-165);
            const perp = pa + Math.PI/2;
            x = (165 + (fcx-165)*pp + Math.cos(perp)*pv);
            y = (165 + (fcy-165)*pp + Math.sin(perp)*pv);
            x = Math.max(20, Math.min(x, this.W-size-20));
            y = Math.max(20, Math.min(y, this.H-size-20));

            const dBall = Math.hypot(x+size/2-165, y+size/2-165);

            // No rectangular overlap with funnel + buffer
            const overlap = !(
                x+size  < this.funnelX-20 ||
                x       > this.funnelX+fs+20 ||
                y+size  < this.funnelY-20 ||
                y       > this.funnelY+fs+20
            );

            const tooClose = this.obstacles.some(o =>
                Math.hypot(x+size/2 - o.x-o.w/2, y+size/2 - o.y-o.h/2) < (size+o.w)/2 + 15
            );

            if (dBall >= 50 && !overlap && !tooClose) { valid = true; break; }
        }

        if (!valid) {
            x = 30 + Math.random() * (this.W - 60 - size);
            y = 30 + Math.random() * (this.H - 60 - size);
        }

        // Moving obstacle motion parameters
        const dirs      = ['x','y','diag'];
        const dir       = dirs[Math.floor(Math.random()*3)];
        const speed     = 0.3 + Math.random() * 0.5;   // units per frame equivalent
        const range     = 40  + Math.random() * 60;
        const phase     = Math.random() * Math.PI * 2;  // start offset

        // Pick obstacle type: rect (default), circle, spinner, laser
        // Lasers only appear from level 40+; spinners from level 20+
        const lvl = this.level;
        let type = 'rect';
        if (lvl >= 40 && Math.random() < 0.2)      type = 'laser';
        else if (lvl >= 20 && Math.random() < 0.25) type = 'spinner';
        else if (lvl >= 10 && Math.random() < 0.3)  type = 'circle';

        // Laser: a sweeping line ‚Äî stored differently (cx, cy, length, angle, sweepSpeed)
        let laserAngle = Math.random() * Math.PI;
        let laserLength = 50 + Math.random() * 60;
        let laserSweepSpeed = (0.015 + Math.random() * 0.02) * (Math.random() < 0.5 ? 1 : -1);

        this.obstacles.push({
            x, y, w: size, h: size,
            isMoving, dir, speed, range, startX: x, startY: y, phase,
            type,
            // circle: radius stored as w/2
            // spinner: rotation angle
            spinAngle: 0, spinSpeed: (0.02 + Math.random() * 0.03) * (Math.random() < 0.5 ? 1 : -1),
            // laser
            laserAngle, laserLength, laserSweepSpeed,
            // clean hit tracking
            hitThisLevel: false
        });
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  EVENT LISTENERS
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    setupEventListeners() {
        this.startButton.addEventListener('click', () => this.requestPermission());
        this.pausedOverlay.addEventListener('click', () => { if (this.gamePaused) this.resumeGame(); });
        this.setupEmergencyCenter();
        this.setupJoystick();
    }

    setupOrientationLock() {
        const overlay = document.getElementById('orientationOverlay');
        const check = () => {
            const landscape = window.matchMedia('(orientation: landscape)').matches;
            overlay.classList.toggle('show', landscape);
        };
        check();
        window.addEventListener('orientationchange', check);
        window.addEventListener('resize', check);
    }

    setupJoystick() {
        const canvas = this.canvas;
        canvas.addEventListener('touchstart', (e) => {
            if (!this.joystickActive) return;
            for (const t of e.changedTouches) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = this.W / rect.width;
                const tx = (t.clientX - rect.left) * scaleX;
                const ty = (t.clientY - rect.top) * scaleX;
                const dx = tx - this.joystickBase.x, dy = ty - this.joystickBase.y;
                if (Math.hypot(dx, dy) < 50) {
                    this.joystickTouchId = t.identifier;
                    break;
                }
            }
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if (!this.joystickActive || this.joystickTouchId === null) return;
            for (const t of e.changedTouches) {
                if (t.identifier !== this.joystickTouchId) continue;
                const rect  = canvas.getBoundingClientRect();
                const scaleX = this.W / rect.width;
                const tx = (t.clientX - rect.left) * scaleX;
                const ty = (t.clientY - rect.top) * scaleX;
                const dx = tx - this.joystickBase.x, dy = ty - this.joystickBase.y;
                const dist = Math.hypot(dx, dy);
                const maxR = 35;
                if (dist <= maxR) {
                    this.joystickThumb.x = tx;
                    this.joystickThumb.y = ty;
                } else {
                    this.joystickThumb.x = this.joystickBase.x + (dx/dist)*maxR;
                    this.joystickThumb.y = this.joystickBase.y + (dy/dist)*maxR;
                }
            }
            e.preventDefault();
        }, { passive: false });

        const endJoy = () => {
            this.joystickTouchId = null;
            this.joystickThumb.x = this.joystickBase.x;
            this.joystickThumb.y = this.joystickBase.y;
        };
        canvas.addEventListener('touchend',    endJoy);
        canvas.addEventListener('touchcancel', endJoy);
    }

    setupEmergencyCenter() {
        const btn = this.emergencyCenter;
        // Double-tap within 500ms centres the ball
        btn.addEventListener('touchend', () => {
            this._ecTapCount++;
            if (this._ecTapCount === 1) {
                this._ecTapTimer = setTimeout(() => { this._ecTapCount = 0; }, 500);
            } else if (this._ecTapCount >= 2) {
                clearTimeout(this._ecTapTimer);
                this._ecTapCount = 0;
                this.centreBall();
            }
        });
        // Also support regular click for desktop testing
        btn.addEventListener('click', () => {
            this._ecTapCount++;
            if (this._ecTapCount === 1) {
                this._ecTapTimer = setTimeout(() => { this._ecTapCount = 0; }, 500);
            } else if (this._ecTapCount >= 2) {
                clearTimeout(this._ecTapTimer);
                this._ecTapCount = 0;
                this.centreBall();
            }
        });
    }

    centreBall() {
        if (!this.gameRunning || this.gamePaused) return;
        this.ballX = 165; this.ballY = 165;
        this.ballVelX = 0; this.ballVelY = 0;
        this.stuckTimer = 0;
        this.emergencyCenter.classList.remove('show');
        this.spawnParticles(175, 175, '#4fd1c7', 12);
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  SOUND ENGINE  (Web Audio API ‚Äî no library needed)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    initAudio() {
        if (this.audioCtx) return;
        try {
            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch(e) { console.warn('Web Audio not available'); }
    }

    _playTone(frequency, type, gainVal, duration, attack=0.01, pitchEnd=null) {
        if (!this.audioCtx || !this.settings.sound) return;
        try {
            const now  = this.audioCtx.currentTime;
            const osc  = this.audioCtx.createOscillator();
            const gain = this.audioCtx.createGain();
            osc.connect(gain);
            gain.connect(this.audioCtx.destination);
            osc.type = type;
            osc.frequency.setValueAtTime(frequency, now);
            if (pitchEnd) osc.frequency.exponentialRampToValueAtTime(pitchEnd, now + duration);
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(gainVal, now + attack);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            osc.start(now);
            osc.stop(now + duration + 0.05);
        } catch(e) {}
    }

    soundWallBounce() {
        this._playTone(110, 'sine', 0.15, 0.12, 0.005, 55);
    }

    soundObstacleHit() {
        this._playTone(220, 'sawtooth', 0.2, 0.15, 0.005, 80);
        setTimeout(() => this._playTone(160, 'square', 0.1, 0.10, 0.005), 30);
    }

    soundNearMiss() {
        if (this._nearMissSoundActive) return;
        this._nearMissSoundActive = true;
        this._playTone(440, 'sine', 0.07, 0.4, 0.05, 660);
        setTimeout(() => { this._nearMissSoundActive = false; }, 600);
    }

    soundLevelComplete() {
        [523, 659, 784].forEach((freq, i) => {
            setTimeout(() => this._playTone(freq, 'sine', 0.26, 0.35, 0.01), i * 130);
        });
        setTimeout(() => this._playTone(1047, 'sine', 0.18, 0.5, 0.01), 420);
    }

    setupAutoPause() {
        window.addEventListener('blur', () => {
            if (this.gameRunning && !this.gamePaused && this.settings.autoPause) this.pauseGame(true);
        });
        document.addEventListener('visibilitychange', () => {
            if (this.gameRunning && !this.gamePaused && this.settings.autoPause && document.hidden) this.pauseGame(true);
        });
        screen.orientation?.addEventListener('change', () => {
            if (this.gameRunning && !this.gamePaused) { this.ballVelX = 0; this.ballVelY = 0; }
        });
    }

    async requestPermission() {
        try {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                const p = await DeviceOrientationEvent.requestPermission();
                if (p === 'granted') this.startGame();
            } else { this.startGame(); }
        } catch(e) { this.startGame(); }
    }

    startGame() {
        this.initAudio();
        // Check if device orientation is available ‚Äî if so, calibrate first
        if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission !== 'function') {
            // Non-iOS: just start calibration directly
            this.startCalibration();
        } else {
            // iOS already granted permission via requestPermission, skip extra calibration step
            this.finishCalibrationAndStart();
        }
    }

    handleOrientation(e) {
        if (!this.gameRunning || this.gamePaused) return;
        const cfg   = this.getCurrentConfig();
        const s     = (this.settings.sensitivity/100) * this.sensitivity * cfg.ballSpeed;
        const gamma = (e.gamma||0) - this.tiltOffsetGamma;
        const beta  = (e.beta ||0) - this.tiltOffsetBeta;
        this.ballVelX += gamma * s * 0.1;
        this.ballVelY += beta  * s * 0.1;
        this.ballVelX = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.ballVelX));
        this.ballVelY = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.ballVelY));
    }

    // Keyboard removed ‚Äî this is a mobile-only tilt game.
    // Space bar still handled for pause convenience on desktop testing.
    handleKeyboard(e) {
        if (e.key === ' ') {
            e.preventDefault();
            if (!this.gameRunning) return;
            if (this.gamePaused) this.resumeGame(); else this.pauseGame();
        }
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  PHYSICS UPDATE (runs inside renderLoop)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    update() {
        if (!this.gameRunning || this.gamePaused || this.levelCompleting) return;

        // Advance level intro (60 frames = 1 second)
        if (this.levelIntroActive) {
            this.levelIntroProgress += 1/60;
            if (this.levelIntroProgress >= 1) {
                this.levelIntroActive   = false;
                this.levelIntroProgress = 0;
            }
            return; // physics frozen during intro
        }

        this.time += 0.016;

        // Virtual joystick input (when gyro unavailable)
        if (this.joystickActive && this.joystickTouchId !== null) {
            const dx = this.joystickThumb.x - this.joystickBase.x;
            const dy = this.joystickThumb.y - this.joystickBase.y;
            const cfg = this.getCurrentConfig();
            const s   = (this.settings.sensitivity/100) * this.sensitivity * cfg.ballSpeed * 0.08;
            this.ballVelX += dx * s;
            this.ballVelY += dy * s;
            this.ballVelX = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.ballVelX));
            this.ballVelY = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.ballVelY));
        }

        // Stuck detection
        const dm = Math.hypot(this.ballX - this.lastBallPos.x, this.ballY - this.lastBallPos.y);
        this.stuckTimer = dm < 0.5 ? this.stuckTimer + 1 : 0;
        this.lastBallPos = { x: this.ballX, y: this.ballY };

        // Physics
        this.ballVelX *= this.friction;
        this.ballVelY *= this.friction;
        this.ballX    += this.ballVelX;
        this.ballY    += this.ballVelY;

        // Wall collisions
        let wallHit = false;
        if (this.ballX <= 0)                    { this.ballX = 0;                    this.ballVelX =  Math.abs(this.ballVelX)*.7; this.spawnParticles(this.ballX, this.ballY, '#ff6b6b', 6); wallHit = true; }
        if (this.ballX >= this.W-this.ballSize) { this.ballX = this.W-this.ballSize; this.ballVelX = -Math.abs(this.ballVelX)*.7; this.spawnParticles(this.ballX, this.ballY, '#ff6b6b', 6); wallHit = true; }
        if (this.ballY <= 0)                    { this.ballY = 0;                    this.ballVelY =  Math.abs(this.ballVelY)*.7; this.spawnParticles(this.ballX, this.ballY, '#ff6b6b', 6); wallHit = true; }
        if (this.ballY >= this.H-this.ballSize) { this.ballY = this.H-this.ballSize; this.ballVelY = -Math.abs(this.ballVelY)*.7; this.spawnParticles(this.ballX, this.ballY, '#ff6b6b', 6); wallHit = true; }
        if (wallHit) { this.shakeCanvas(); this.soundWallBounce(); }

        // Update obstacle positions and angles
        this.obstacles.forEach(o => {
            // Spinner always rotates regardless of isMoving
            if (o.type === 'spinner') o.spinAngle += o.spinSpeed;
            // Laser sweeps
            if (o.type === 'laser')   o.laserAngle += o.laserSweepSpeed;

            if (!o.isMoving) return;
            const t = this.time * o.speed * Math.PI * 2 / 3 + o.phase;
            if      (o.dir === 'x')  { o.x = o.startX + Math.sin(t) * o.range; }
            else if (o.dir === 'y')  { o.y = o.startY + Math.sin(t) * o.range; }
            else                     { o.x = o.startX + Math.sin(t) * o.range * .7;
                                       o.y = o.startY + Math.cos(t) * o.range * .7; }
            o.x = Math.max(5, Math.min(o.x, this.W - o.w - 5));
            o.y = Math.max(5, Math.min(o.y, this.H - o.h - 5));
        });

        // Obstacle collisions ‚Äî type-aware with AABB push-out
        this.obstacles.forEach(o => {
            const bcx = this.ballX + this.ballSize/2, bcy = this.ballY + this.ballSize/2;
            const br  = this.ballSize / 2;
            let hit   = false;

            if (o.type === 'circle') {
                // Circle collision
                const cx = o.x + o.w/2, cy = o.y + o.h/2, cr = o.w/2;
                const dist = Math.hypot(bcx-cx, bcy-cy);
                if (dist < br + cr) {
                    hit = true;
                    const nx = (bcx-cx)/dist, ny = (bcy-cy)/dist;
                    // Push ball out
                    const overlap = br + cr - dist;
                    this.ballX += nx * overlap;
                    this.ballY += ny * overlap;
                    // Reflect velocity
                    const dot = this.ballVelX*nx + this.ballVelY*ny;
                    this.ballVelX = (this.ballVelX - 2*dot*nx) * 0.65;
                    this.ballVelY = (this.ballVelY - 2*dot*ny) * 0.65;
                }
            } else if (o.type === 'laser') {
                // Laser line segment collision
                const cx = o.x + o.w/2, cy = o.y + o.h/2;
                const hl = o.laserLength / 2;
                const lx1 = cx + Math.cos(o.laserAngle) * hl;
                const ly1 = cy + Math.sin(o.laserAngle) * hl;
                const lx2 = cx - Math.cos(o.laserAngle) * hl;
                const ly2 = cy - Math.sin(o.laserAngle) * hl;
                // Point-to-segment distance
                const dx = lx2-lx1, dy = ly2-ly1;
                const lenSq = dx*dx + dy*dy;
                let t = ((bcx-lx1)*dx + (bcy-ly1)*dy) / lenSq;
                t = Math.max(0, Math.min(1, t));
                const closestX = lx1 + t*dx, closestY = ly1 + t*dy;
                const distToLine = Math.hypot(bcx-closestX, bcy-closestY);
                if (distToLine < br + 4) {
                    hit = true;
                    // Reflect off laser normal
                    const nx = (bcx-closestX)/distToLine, ny = (bcy-closestY)/distToLine;
                    const overlap = br + 4 - distToLine;
                    this.ballX += nx * overlap;
                    this.ballY += ny * overlap;
                    const dot = this.ballVelX*nx + this.ballVelY*ny;
                    this.ballVelX = (this.ballVelX - 2*dot*nx) * 0.65;
                    this.ballVelY = (this.ballVelY - 2*dot*ny) * 0.65;
                }
            } else {
                // Rect or spinner ‚Äî AABB collision
                if (this.ballX < o.x+o.w && this.ballX+this.ballSize > o.x &&
                    this.ballY < o.y+o.h && this.ballY+this.ballSize > o.y) {
                    hit = true;

                const bcx = this.ballX+this.ballSize/2, bcy = this.ballY+this.ballSize/2;

                // ‚îÄ‚îÄ Push-out: find the shallowest axis of overlap and eject the
                //    ball along it so it never gets embedded in a corner. ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                const overlapLeft   = (o.x + o.w) - this.ballX;          // dist to push right
                const overlapRight  = (this.ballX + this.ballSize) - o.x; // dist to push left
                const overlapTop    = (o.y + o.h) - this.ballY;           // dist to push down
                const overlapBottom = (this.ballY + this.ballSize) - o.y; // dist to push up

                const minOverlapX = Math.min(overlapLeft, overlapRight);
                const minOverlapY = Math.min(overlapTop, overlapBottom);

                if (minOverlapX < minOverlapY) {
                    // Resolve horizontally ‚Äî shallower penetration on X axis
                    if (overlapLeft < overlapRight) {
                        this.ballX = o.x + o.w;             // push ball to right of obstacle
                        this.ballVelX = Math.abs(this.ballVelX) * 0.6;
                    } else {
                        this.ballX = o.x - this.ballSize;   // push ball to left of obstacle
                        this.ballVelX = -Math.abs(this.ballVelX) * 0.6;
                    }
                    this.ballVelY *= 0.85; // bleed a little Y energy too
                } else {
                    // Resolve vertically ‚Äî shallower penetration on Y axis
                    if (overlapTop < overlapBottom) {
                        this.ballY = o.y + o.h;             // push ball below obstacle
                        this.ballVelY = Math.abs(this.ballVelY) * 0.6;
                    } else {
                        this.ballY = o.y - this.ballSize;   // push ball above obstacle
                        this.ballVelY = -Math.abs(this.ballVelY) * 0.6;
                    }
                    this.ballVelX *= 0.85;
                }

                    this.ballVelX = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.ballVelX));
                    this.ballVelY = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.ballVelY));
                } // end rect
            }

            if (hit) {
                this.ballVelX = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.ballVelX));
                this.ballVelY = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.ballVelY));
                this.spawnParticles(bcx, bcy, o.isMoving ? '#9f7aea' : (o.type==='laser'?'#fc8181':o.type==='circle'?'#4fd1c7':'#d69e2e'), 6);
                this.shakeCanvas();
                this.soundObstacleHit();
                if (this.settings.haptic && navigator.vibrate) navigator.vibrate([30,10,30]);
                this.levelAttempts++;
                this.levelHitCount++;
                this.combo = 0; // break combo on any obstacle hit
                this.checkSkipLevelAvailability();
            }
        });

        // Funnel collision + near-miss proximity
        if (!this.levelCompleting) {
            const cfg = this.getCurrentConfig();
            const fs  = Math.max(cfg.funnelSize, 30);
            const fcx = this.funnelX + fs/2, fcy = this.funnelY + fs/2;
            const bcx = this.ballX + this.ballSize/2, bcy = this.ballY + this.ballSize/2;
            const distToFunnel = Math.hypot(bcx-fcx, bcy-fcy);

            if (distToFunnel < fs/2 - 5) {
                this.levelComplete();
            }

            // Near-miss: ramp from 0 (far) to 1 (just outside edge)
            const nearZone = fs * 1.8;
            this.nearMissProximity = Math.max(0, 1 - (distToFunnel - fs/2) / nearZone);

            // Play a soft chime when ball enters the near-miss zone
            if (this.nearMissProximity > 0.65) this.soundNearMiss();
            else this._nearMissSoundActive = false; // reset when ball leaves zone
        }

        // Emergency centre button: show after 5 seconds stuck (300 frames @ 60fps)
        if (this.gameRunning && !this.gamePaused) {
            if (this.stuckTimer > 300) {
                this.emergencyCenter.classList.add('show');
            } else {
                this.emergencyCenter.classList.remove('show');
            }
        }

        // Update trail
        if (this.settings.trail) {
            this.trail.push({ x: this.ballX+this.ballSize/2, y: this.ballY+this.ballSize/2, alpha:1 });
            if (this.trail.length > 20) this.trail.shift();
        }

        // Age particles
        this.particles = this.particles.filter(p => {
            p.x += p.vx; p.y += p.vy; p.vy += .15; // gravity
            p.life--;
            return p.life > 0;
        });

        // Age shockwaves
        this.shockwaves = this.shockwaves.filter(s => {
            s.radius += 4; s.life--;
            return s.life > 0;
        });

        // Age score popups
        this.scorePopups = this.scorePopups.filter(p => {
            p.y -= 1; p.life--;
            return p.life > 0;
        });

        // Tutorial progress (level 1 only, fades out after 3 seconds or first movement)
        if (this.tutorialActive) {
            const moving = Math.abs(this.ballVelX) > 0.3 || Math.abs(this.ballVelY) > 0.3;
            this.tutorialProgress += moving ? 0.025 : 0.004;
            if (this.tutorialProgress >= 1) this.tutorialActive = false;
        }

        // Background theme ‚Äî smoothly interpolate toward target colour
        const target = this.getBgTargetColour();
        this.bgTheme.r += (target.r - this.bgTheme.r) * 0.005;
        this.bgTheme.g += (target.g - this.bgTheme.g) * 0.005;
        this.bgTheme.b += (target.b - this.bgTheme.b) * 0.005;

        // Funnel pulse speed is now managed inside drawFunnel() based on nearMissProximity
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  CANVAS SHAKE
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    shakeCanvas() {
        if (this._shakeTimer) return;
        let t = 0;
        const shake = () => {
            t++;
            this.shakeOffsetX = (Math.random()-.5) * 6 * (1 - t/8);
            this.shakeOffsetY = (Math.random()-.5) * 6 * (1 - t/8);
            if (t < 8) this._shakeTimer = requestAnimationFrame(shake);
            else { this.shakeOffsetX = 0; this.shakeOffsetY = 0; this._shakeTimer = null; }
        };
        this._shakeTimer = requestAnimationFrame(shake);
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  PARTICLE SPAWNING
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    spawnParticles(x, y, color, count=8) {
        for (let i = 0; i < count; i++) {
            const angle = (Math.PI*2*i)/count + Math.random()*.3;
            const speed = 2 + Math.random()*3;
            this.particles.push({
                x, y,
                vx: Math.cos(angle)*speed,
                vy: Math.sin(angle)*speed - Math.random()*2,
                life: 20 + Math.random()*20,
                color,
                size: 2 + Math.random()*3
            });
        }
    }

    spawnExplosion(x, y) {
        // Big burst for level complete
        const colors = ['#68d391','#ffd700','#4fd1c7','#f56565','#63b3ed'];
        for (let i = 0; i < 40; i++) {
            const angle = Math.random()*Math.PI*2;
            const speed = 2 + Math.random()*6;
            this.particles.push({
                x, y,
                vx: Math.cos(angle)*speed,
                vy: Math.sin(angle)*speed - Math.random()*3,
                life: 40 + Math.random()*30,
                color: colors[Math.floor(Math.random()*colors.length)],
                size: 3 + Math.random()*4
            });
        }
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  RENDER ‚Äî called every animation frame
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    renderLoop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.renderLoop());
    }

    draw() {
        const ctx = this.ctx;
        const sx  = this.shakeOffsetX || 0;
        const sy  = this.shakeOffsetY || 0;

        // Clear
        ctx.clearRect(0, 0, this.W, this.H);

        // Arena background ‚Äî tinted by difficulty theme
        const tr = Math.round(this.bgTheme.r), tg = Math.round(this.bgTheme.g), tb = Math.round(this.bgTheme.b);
        const bg = ctx.createRadialGradient(175,175,10, 175,175,250);
        bg.addColorStop(0, `rgb(${tr+17},${tg+19},${tb+24})`);
        bg.addColorStop(1, `rgb(${tr},${tg},${tb})`);
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, this.W, this.H);

        // Subtle grid
        this.drawGrid(ctx);

        ctx.save();
        ctx.translate(sx, sy);

        // Draw trail
        this.drawTrail(ctx);

        // Draw funnel (target)
        this.drawFunnel(ctx);

        // Draw obstacles
        this.drawObstacles(ctx);

        // Draw particles
        this.drawParticles(ctx);

        // Draw shockwaves
        this.drawShockwaves(ctx);

        // Draw ball (on top of everything except popups)
        if (this.gameRunning || !this.gameRunning) { // always draw
            this.drawBall(ctx);
        }

        // Draw score popups
        this.drawScorePopups(ctx);

        // Draw tutorial arrows (level 1)
        if (this.tutorialActive && this.gameRunning && !this.levelIntroActive) {
            this.drawTutorial(ctx);
        }

        // Draw virtual joystick
        if (this.joystickActive && this.gameRunning && !this.gamePaused && !this.levelIntroActive) {
            this.drawJoystick(ctx);
        }

        // Draw calibration screen
        if (this.calibrating) {
            this.drawCalibrationScreen(ctx);
        }

        // Draw level intro overlay (on top of everything)
        if (this.levelIntroActive) {
            this.drawLevelIntro(ctx);
        }

        ctx.restore();
    }

    drawLevelIntro(ctx) {
        const p   = this.levelIntroProgress; // 0..1
        // Phase: 0-0.3 zoom in, 0.3-0.7 hold, 0.7-1.0 fade out
        let alpha, scale;
        if (p < 0.3) {
            alpha = p / 0.3;
            scale = 0.4 + (p / 0.3) * 0.6;
        } else if (p < 0.7) {
            alpha = 1;
            scale = 1;
        } else {
            alpha = 1 - (p - 0.7) / 0.3;
            scale = 1 + (p - 0.7) * 0.5;
        }

        const cfg  = this.getCurrentConfig();
        const diff = cfg.difficulty.toUpperCase();
        const diffColors = {
            EASY:'#68d391', MEDIUM:'#f6ad55', HARD:'#f56565',
            EXPERT:'#9f7aea', LEGENDARY:'#ffd700', MASTER:'#e53e3e',
            GRANDMASTER:'#63b3ed', ULTIMATE:'#ffd700'
        };
        const col = diffColors[diff] || '#63b3ed';

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(this.W/2, this.H/2);
        ctx.scale(scale, scale);

        // Dark scrim
        ctx.fillStyle = `rgba(0,0,0,0.55)`;
        ctx.fillRect(-this.W/2/scale, -this.H/2/scale, this.W/scale, this.H/scale);

        // Level number
        ctx.textAlign    = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor  = col;
        ctx.shadowBlur   = 30;
        ctx.fillStyle    = '#ffffff';
        ctx.font         = 'bold 64px Arial';
        ctx.fillText(`${this.levelIntroLevel}`, 0, -18);

        // "LEVEL" label above
        ctx.font      = 'bold 14px Arial';
        ctx.fillStyle = col;
        ctx.shadowBlur = 12;
        ctx.fillText('LEVEL', 0, -52);

        // Difficulty badge below
        ctx.font      = 'bold 13px Arial';
        ctx.fillStyle = col;
        ctx.shadowBlur = 8;
        ctx.fillText(diff, 0, 20);

        // Decorative lines either side of number
        ctx.shadowBlur  = 0;
        ctx.strokeStyle = col;
        ctx.globalAlpha = alpha * 0.6;
        ctx.lineWidth   = 1.5;
        ctx.beginPath(); ctx.moveTo(-80, 0); ctx.lineTo(-28, 0); ctx.stroke();
        ctx.beginPath(); ctx.moveTo( 28, 0); ctx.lineTo( 80, 0); ctx.stroke();

        ctx.restore();
    }

    drawGrid(ctx) {
        ctx.save();
        ctx.strokeStyle = 'rgba(99,179,237,0.04)';
        ctx.lineWidth   = 1;
        for (let x = 0; x <= this.W; x += 35) {
            ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,this.H); ctx.stroke();
        }
        for (let y = 0; y <= this.H; y += 35) {
            ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(this.W,y); ctx.stroke();
        }
        ctx.restore();
    }

    drawTrail(ctx) {
        if (!this.trail.length) return;
        this.trail.forEach((pt, i) => {
            const t     = i / this.trail.length;
            const r     = 2 + t * 7;          // grows toward ball
            const alpha = t * 0.55;

            ctx.save();
            const g = ctx.createRadialGradient(pt.x, pt.y, 0, pt.x, pt.y, r*2);
            g.addColorStop(0, `rgba(245,101,101,${alpha})`);
            g.addColorStop(1, `rgba(245,101,101,0)`);
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(pt.x, pt.y, r*2, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        });
    }

    drawFunnel(ctx) {
        const cfg  = this.getCurrentConfig();
        const fs   = Math.max(cfg.funnelSize, 30);
        const cx   = this.funnelX + fs/2;
        const cy   = this.funnelY + fs/2;
        const r    = fs/2;
        const nm   = this.nearMissProximity; // 0..1

        // Near-miss: speed up pulse and increase glow intensity as ball approaches
        const pulseSpeed = 0.05 + nm * 0.18;       // faster flicker when close
        this.funnelPulsePhase += pulseSpeed;
        const pulseAmt = 0.05 + nm * 0.12;          // bigger throb when close
        const pulse    = 1 + Math.sin(this.funnelPulsePhase) * pulseAmt;

        // Glow intensity scales with proximity
        const glowAlpha  = 0.25 + nm * 0.55;        // up to 0.8 when very close
        const glowRadius = r * (2 + nm * 1.5);      // glow spreads outward

        ctx.save();

        // Outer proximity glow ‚Äî grows and brightens as ball nears
        const glow = ctx.createRadialGradient(cx, cy, r*0.3, cx, cy, glowRadius);
        glow.addColorStop(0, `rgba(104,211,145,${glowAlpha})`);
        glow.addColorStop(0.6, `rgba(104,211,145,${glowAlpha * 0.3})`);
        glow.addColorStop(1, 'rgba(104,211,145,0)');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(cx, cy, glowRadius, 0, Math.PI*2);
        ctx.fill();

        // Second warm ring when very close (yellow-green urgency tint)
        if (nm > 0.5) {
            const urgency = (nm - 0.5) * 2; // 0..1 only in last half of approach
            const ug = ctx.createRadialGradient(cx, cy, r*0.5, cx, cy, r*1.6);
            ug.addColorStop(0, `rgba(255,237,100,${urgency * 0.3})`);
            ug.addColorStop(1, 'rgba(255,237,100,0)');
            ctx.fillStyle = ug;
            ctx.beginPath();
            ctx.arc(cx, cy, r*1.6, 0, Math.PI*2);
            ctx.fill();
        }

        // Main circle ‚Äî brightens slightly on near-miss
        const brightBoost = nm * 0.15;
        const grad = ctx.createRadialGradient(cx-r*.3, cy-r*.3, r*.1, cx, cy, r);
        grad.addColorStop(0, `hsl(${141 + nm*15}, ${80+nm*20}%, ${65+nm*15}%)`);
        grad.addColorStop(0.5, '#48bb78');
        grad.addColorStop(1, '#276749');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(cx, cy, r*pulse, 0, Math.PI*2);
        ctx.fill();

        // Inner ring highlight
        ctx.strokeStyle = `rgba(255,255,255,${0.4 + nm*0.3})`;
        ctx.lineWidth   = 2;
        ctx.beginPath();
        ctx.arc(cx-r*.15, cy-r*.15, r*.4, Math.PI*1.1, Math.PI*1.9);
        ctx.stroke();

        // Spinning dashed ring ‚Äî spins faster when ball is close
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(this.time * (1.5 + nm * 3));
        ctx.setLineDash([4, 6]);
        ctx.strokeStyle = `rgba(104,211,145,${0.6 + nm*0.35})`;
        ctx.lineWidth   = 1.5 + nm * 1.5;
        ctx.beginPath();
        ctx.arc(0, 0, r*pulse + 5, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();

        // Outer border
        ctx.strokeStyle = `rgba(104,211,145,${0.8 + nm*0.2})`;
        ctx.lineWidth   = 2 + nm * 2;
        ctx.shadowColor = '#68d391';
        ctx.shadowBlur  = nm * 20;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.arc(cx, cy, r*pulse, 0, Math.PI*2);
        ctx.stroke();

        ctx.restore();
    }

    drawObstacles(ctx) {
        this.obstacles.forEach(o => {
            const cx = o.x + o.w/2, cy = o.y + o.h/2;
            ctx.save();

            if (o.type === 'circle') {
                const r = o.w/2;
                // Glow
                if (o.isMoving) {
                    const g = ctx.createRadialGradient(cx,cy,0,cx,cy,r*1.8);
                    g.addColorStop(0,'rgba(79,209,197,.3)'); g.addColorStop(1,'rgba(79,209,197,0)');
                    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx,cy,r*1.8,0,Math.PI*2); ctx.fill();
                }
                const grad = ctx.createRadialGradient(cx-r*.3,cy-r*.3,r*.1,cx,cy,r);
                grad.addColorStop(0, o.isMoving ? '#4fd1c7' : '#d69e2e');
                grad.addColorStop(1, o.isMoving ? '#2c7a7b' : '#744210');
                ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
                ctx.strokeStyle = o.isMoving ? '#4fd1c7' : '#d69e2e';
                ctx.lineWidth=1.5; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();
                // Highlight
                ctx.strokeStyle='rgba(255,255,255,0.3)'; ctx.lineWidth=1;
                ctx.beginPath(); ctx.arc(cx-r*.2,cy-r*.2,r*.4,Math.PI*1.1,Math.PI*1.9); ctx.stroke();
                ctx.restore(); return;
            }

            if (o.type === 'laser') {
                const hl = o.laserLength/2;
                const x1 = cx + Math.cos(o.laserAngle)*hl, y1 = cy + Math.sin(o.laserAngle)*hl;
                const x2 = cx - Math.cos(o.laserAngle)*hl, y2 = cy - Math.sin(o.laserAngle)*hl;
                // Glow
                ctx.shadowColor = '#f56565'; ctx.shadowBlur = 14;
                const grad = ctx.createLinearGradient(x1,y1,x2,y2);
                grad.addColorStop(0,'rgba(245,101,101,0)');
                grad.addColorStop(0.5,'rgba(245,101,101,1)');
                grad.addColorStop(1,'rgba(245,101,101,0)');
                ctx.strokeStyle=grad; ctx.lineWidth=3;
                ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
                // Core
                ctx.shadowBlur=0; ctx.strokeStyle='rgba(255,200,200,0.8)'; ctx.lineWidth=1;
                ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
                // Pivot dot
                ctx.fillStyle='#f56565'; ctx.beginPath(); ctx.arc(cx,cy,4,0,Math.PI*2); ctx.fill();
                ctx.restore(); return;
            }

            ctx.translate(cx, cy);

            if (o.type === 'spinner') {
                ctx.rotate(o.spinAngle);
                // Cross/plus shape
                const arm = o.w * 0.45, thick = o.w * 0.22;
                ctx.fillStyle = o.isMoving ? '#805ad5' : '#c05621';
                ctx.shadowColor = o.isMoving ? '#9f7aea' : '#d69e2e'; ctx.shadowBlur = 8;
                // Horizontal bar
                ctx.fillRect(-arm, -thick/2, arm*2, thick);
                // Vertical bar
                ctx.fillRect(-thick/2, -arm, thick, arm*2);
                ctx.strokeStyle = o.isMoving ? '#9f7aea' : '#d69e2e';
                ctx.lineWidth = 1; ctx.shadowBlur = 0;
                ctx.strokeRect(-arm, -thick/2, arm*2, thick);
                ctx.strokeRect(-thick/2, -arm, thick, arm*2);
                ctx.restore(); return;
            }

            ctx.translate(0, 0); // already at cx,cy from translate above

            if (o.isMoving) {
                // Purple moving obstacle with glow
                const glowG = ctx.createRadialGradient(0,0,0, 0,0, Math.max(o.w,o.h));
                glowG.addColorStop(0, 'rgba(159,122,234,0.3)');
                glowG.addColorStop(1, 'rgba(159,122,234,0)');
                ctx.fillStyle = glowG;
                ctx.fillRect(-o.w/2-8, -o.h/2-8, o.w+16, o.h+16);

                const g = ctx.createLinearGradient(-o.w/2,-o.h/2, o.w/2, o.h/2);
                g.addColorStop(0, '#553c9a');
                g.addColorStop(1, '#805ad5');
                ctx.fillStyle = g;

                // Round rect
                this.roundRect(ctx, -o.w/2, -o.h/2, o.w, o.h, 5);
                ctx.fill();
                ctx.strokeStyle = '#9f7aea';
                ctx.lineWidth = 1.5;
                this.roundRect(ctx, -o.w/2, -o.h/2, o.w, o.h, 5);
                ctx.stroke();

                // Pulse stripe on moving obstacles
                const stripeAlpha = 0.2 + Math.sin(this.time*4 + o.phase)*0.15;
                ctx.fillStyle = `rgba(255,255,255,${stripeAlpha})`;
                ctx.fillRect(-o.w/2+2, -2, o.w-4, 4);

            } else {
                // Brown static obstacle
                const g = ctx.createLinearGradient(-o.w/2,-o.h/2, o.w/2, o.h/2);
                g.addColorStop(0, '#975a16');
                g.addColorStop(1, '#744210');
                ctx.fillStyle = g;
                this.roundRect(ctx, -o.w/2, -o.h/2, o.w, o.h, 4);
                ctx.fill();
                ctx.strokeStyle = '#d69e2e';
                ctx.lineWidth = 1;
                this.roundRect(ctx, -o.w/2, -o.h/2, o.w, o.h, 4);
                ctx.stroke();

                // Highlight top edge
                ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-o.w/2+4, -o.h/2+2);
                ctx.lineTo( o.w/2-4, -o.h/2+2);
                ctx.stroke();
            }
            ctx.restore();
        });
    }

    // Helper: rounded rectangle path
    roundRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x+r, y);
        ctx.lineTo(x+w-r, y);
        ctx.quadraticCurveTo(x+w, y, x+w, y+r);
        ctx.lineTo(x+w, y+h-r);
        ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
        ctx.lineTo(x+r, y+h);
        ctx.quadraticCurveTo(x, y+h, x, y+h-r);
        ctx.lineTo(x, y+r);
        ctx.quadraticCurveTo(x, y, x+r, y);
        ctx.closePath();
    }

    drawBall(ctx) {
        const cx = this.ballX + this.ballSize/2;
        const cy = this.ballY + this.ballSize/2;
        const r  = this.ballSize/2;

        ctx.save();

        // Outer glow
        const glow = ctx.createRadialGradient(cx, cy, r*.5, cx, cy, r*2.5);
        glow.addColorStop(0, 'rgba(245,101,101,0.4)');
        glow.addColorStop(1, 'rgba(245,101,101,0)');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(cx, cy, r*2.5, 0, Math.PI*2);
        ctx.fill();

        // Ball body
        const speed = Math.hypot(this.ballVelX, this.ballVelY);
        const gR = ctx.createRadialGradient(cx-r*.3, cy-r*.4, r*.1, cx, cy, r);
        gR.addColorStop(0, '#ffffff');
        gR.addColorStop(0.3, '#fc8181');
        gR.addColorStop(1, '#c53030');
        ctx.fillStyle = gR;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI*2);
        ctx.fill();

        // Specular highlight
        const hl = ctx.createRadialGradient(cx-r*.3, cy-r*.35, 0, cx-r*.3, cy-r*.35, r*.5);
        hl.addColorStop(0, 'rgba(255,255,255,0.7)');
        hl.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = hl;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI*2);
        ctx.fill();

        // Speed-based motion blur streak
        if (speed > 2) {
            const mx = -this.ballVelX * 2, my = -this.ballVelY * 2;
            const streak = ctx.createLinearGradient(cx, cy, cx+mx, cy+my);
            streak.addColorStop(0, `rgba(245,101,101,${Math.min(speed/this.maxVelocity*.6, 0.5)})`);
            streak.addColorStop(1, 'rgba(245,101,101,0)');
            ctx.fillStyle = streak;
            ctx.beginPath();
            ctx.arc(cx, cy, r*.8, 0, Math.PI*2);
            ctx.fill();
        }

        ctx.restore();
    }

    drawParticles(ctx) {
        this.particles.forEach(p => {
            const alpha = p.life / (p.life + 10); // softer fade
            ctx.save();
            ctx.globalAlpha = alpha * 0.9;
            ctx.fillStyle = p.color;
            ctx.shadowColor = p.color;
            ctx.shadowBlur  = 6;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        });
    }

    drawShockwaves(ctx) {
        this.shockwaves.forEach(s => {
            const t = 1 - s.life / s.maxLife;
            ctx.save();
            ctx.globalAlpha = (1-t) * 0.7;
            ctx.strokeStyle = '#68d391';
            ctx.lineWidth   = 3 * (1-t);
            ctx.shadowColor = '#68d391';
            ctx.shadowBlur  = 15;
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.radius, 0, Math.PI*2);
            ctx.stroke();
            ctx.restore();
        });
    }

    drawScorePopups(ctx) {
        this.scorePopups.forEach(p => {
            const t = p.life / p.maxLife;
            ctx.save();
            ctx.globalAlpha = t;
            ctx.fillStyle   = p.color || '#ffd700';
            ctx.font        = `bold ${14 + (1-t)*6}px Arial`;
            ctx.textAlign   = 'center';
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur  = 10;
            ctx.fillText(p.text, p.x, p.y);
            ctx.restore();
        });
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  LEVEL COMPLETE
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    levelComplete() {
        if (this.levelCompleting) return;
        this.levelCompleting = true;
        this.stopTimer();

        const cfg = this.getCurrentConfig();
        const fs  = Math.max(cfg.funnelSize, 30);
        const fcx = this.funnelX + fs/2, fcy = this.funnelY + fs/2;

        // Shockwave rings
        for (let i = 0; i < 3; i++) {
            setTimeout(() => {
                this.shockwaves.push({ x:fcx, y:fcy, radius:5, maxRadius:fs*2, life:30, maxLife:30 });
            }, i * 150);
        }

        // Explosion burst
        this.spawnExplosion(fcx, fcy);

        // Score with combo multiplier
        const mult  = this.levelHitCount === 0 ? (this.combo++, this.getComboMultiplier()) : (this.combo = 0, 1);
        const bonus = Math.round(this.level * 100 * mult);
        this.score += bonus;
        this.levelHitCount = 0;

        // Score popup
        const popColor = mult > 1 ? '#ffd700' : '#68d391';
        this.scorePopups.push({ x: fcx, y: fcy - 20, text: `+${bonus}`, life: 60, maxLife: 60, color: popColor });
        this.showComboPopup(mult, fcx, fcy);

        if (this.score > this.bestScore) {
            this.bestScore = this.score;
            try { localStorage.setItem('tiltSphereBest', this.bestScore.toString()); } catch(e) {}
        }

        if (this.settings.haptic && navigator.vibrate) {
            // Sync with soundLevelComplete 4-note fanfare (C-E-G + octave)
            navigator.vibrate([80,50,80,50,80,50,200]);
        }
        this.soundLevelComplete();

        this.checkAchievements();

        if (this.gameMode === 'daily')   this.saveDailyScore();
        if (this.gameMode === 'endless') { this.endlessLevel++; this.saveEndlessScore(); }

        this.level++;

        if (this.gameMode === 'normal' && this.level > this.levelConfigs.length) { this.endGame(); return; }

        this.saveGame();
        this.updateUI();

        // Animate ball spiralling into funnel, then setup next level
        this.animateBallIntoFunnel(fcx, fcy, () => {
            this.setupLevel();
            this.levelCompleting = false;
        });
    }

    animateBallIntoFunnel(fcx, fcy, callback) {
        this.ballVelX = 0; this.ballVelY = 0;
        const startTime = Date.now();
        const duration  = 1000;
        const initR = Math.hypot(this.ballX+this.ballSize/2 - fcx, this.ballY+this.ballSize/2 - fcy);

        const animate = () => {
            const progress = Math.min((Date.now()-startTime)/duration, 1);
            if (progress >= 1) { setTimeout(callback, 200); return; }

            const ease   = 1 - Math.pow(1-progress, 3);
            const radius = initR * (1-ease);
            const angle  = progress * Math.PI * 6;
            const scale  = 1 - progress * 0.9;

            this.ballX = fcx + Math.cos(angle)*radius - this.ballSize/2;
            this.ballY = fcy + Math.sin(angle)*radius - this.ballSize/2;
            this._ballAnimScale  = Math.max(scale, 0.05);
            this._ballAnimOpacity = scale;

            if (Math.random() < 0.3) {
                this.spawnParticles(this.ballX+this.ballSize/2, this.ballY+this.ballSize/2, '#4fd1c7', 2);
            }
            requestAnimationFrame(animate);
        };
        animate();
    }

    // Override drawBall to respect spiral-in scale
    drawBall(ctx) {
        const cx = this.ballX + this.ballSize/2;
        const cy = this.ballY + this.ballSize/2;
        const r  = this.ballSize/2 * (this._ballAnimScale ?? 1);
        if (r <= 0) return;

        ctx.save();
        ctx.globalAlpha = this._ballAnimOpacity ?? 1;

        // Outer glow ‚Äî skin coloured
        const skinGlows = ['rgba(245,101,101,ALPHA)','rgba(99,179,237,ALPHA)','rgba(104,211,145,ALPHA)','rgba(255,215,0,ALPHA)','rgba(183,148,244,ALPHA)'];
        const glowBase = (skinGlows[this.activeSkin]||skinGlows[0]).replace('ALPHA','0.4');
        const glowFade = (skinGlows[this.activeSkin]||skinGlows[0]).replace('ALPHA','0');
        const glow = ctx.createRadialGradient(cx,cy,r*.5, cx,cy,r*2.5);
        glow.addColorStop(0, glowBase);
        glow.addColorStop(1, glowFade);
        ctx.fillStyle = glow;
        ctx.beginPath(); ctx.arc(cx,cy,r*2.5,0,Math.PI*2); ctx.fill();

        // Ball body ‚Äî skin-coloured
        const skinPalettes = [
            ['#ffffff','#fc8181','#c53030'], // 0 classic red
            ['#ffffff','#63b3ed','#1a56a0'], // 1 ocean blue
            ['#ffffff','#68d391','#276749'], // 2 forest green
            ['#ffffff','#ffd700','#b7791f'], // 3 gold
            ['#ffffff','#b794f4','#553c9a'], // 4 plasma purple
        ];
        const pal = skinPalettes[this.activeSkin] || skinPalettes[0];
        const gR = ctx.createRadialGradient(cx-r*.3,cy-r*.4,r*.1, cx,cy,r);
        gR.addColorStop(0, pal[0]);
        gR.addColorStop(0.3, pal[1]);
        gR.addColorStop(1, pal[2]);
        ctx.fillStyle = gR;
        ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();

        // Specular highlight
        const hl = ctx.createRadialGradient(cx-r*.3,cy-r*.35,0, cx-r*.3,cy-r*.35,r*.5);
        hl.addColorStop(0, 'rgba(255,255,255,0.7)');
        hl.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = hl;
        ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();

        // Speed streak
        const speed = Math.hypot(this.ballVelX, this.ballVelY);
        if (speed > 2 && !this.levelCompleting) {
            const mx = -this.ballVelX*2, my = -this.ballVelY*2;
            const streak = ctx.createLinearGradient(cx,cy, cx+mx,cy+my);
            const streakCol = (skinGlows[this.activeSkin]||skinGlows[0]).replace('ALPHA', Math.min(speed/this.maxVelocity*.6,0.5).toString());
            const streakFade = (skinGlows[this.activeSkin]||skinGlows[0]).replace('ALPHA','0');
            streak.addColorStop(0, streakCol);
            streak.addColorStop(1, streakFade);
            ctx.fillStyle = streak;
            ctx.beginPath(); ctx.arc(cx,cy,r*.8,0,Math.PI*2); ctx.fill();
        }

        ctx.restore();

        // Reset after animation
        if (!this.levelCompleting) {
            this._ballAnimScale   = 1;
            this._ballAnimOpacity = 1;
        }
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  GAME MANAGEMENT (unchanged logic from DOM version)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    endGame() {
        this.gameRunning = false; this.levelCompleting = false;
        alert(`üéâ Congratulations!\n\nYou completed all ${this.levelConfigs.length} levels!\nFinal Score: ${this.score}\nBest Score: ${this.bestScore}\n\nYou are a TiltSphere Master!`);
        this.level = 1; this.score = 0;
        this.startButton.style.display = 'block';
        this.startButton.textContent = 'PLAY AGAIN';
        document.getElementById('menuButtons').style.display = 'none';
        this.setupLevel(); this.updateUI();
    }

    pauseGame(auto=false) {
        if (!this.gameRunning) return;
        this.gamePaused = true;
        this.pausedOverlay.classList.add('show');
        document.getElementById('pauseMsg').textContent = auto
            ? 'Game auto-paused ‚Äî Click to resume'
            : 'Click anywhere to resume';
    }

    resumeGame() {
        if (!this.gamePaused) return;
        this.gamePaused = false;
        this.pausedOverlay.classList.remove('show');
        this.ballVelX = 0; this.ballVelY = 0;
    }

    checkSkipLevelAvailability() {
        if (this.levelAttempts >= 10) {
            document.getElementById('skipLevelHint').classList.add('show');
            document.getElementById('skipButton').style.display = 'inline-block';
        }
    }

    skipLevel() {
        if (this.levelAttempts < 10) return;
        if (confirm("Skip this level? You won't get points for it.")) {
            this.level++;
            if (this.level > this.levelConfigs.length) { this.endGame(); return; }
            this.saveGame(); this.updateUI(); this.setupLevel();
            this.showNotification('Level Skipped','No points awarded',2000);
        }
    }

    resetProgress() {
        if (!confirm('Reset all progress? This cannot be undone.')) return;
        try {
            ['tiltSphereSave','tiltSphereBest','tiltSphereAchievements','tiltSphereSettings','tiltSphereScores']
                .forEach(k => localStorage.removeItem(k));
        } catch(e) {}
        this.level=1; this.score=0; this.bestScore=0; this.achievements=[]; this.lives=3; this.combo=0;
        this.levelAttempts=0; this.gameRunning=false; this.levelCompleting=false;
        this.stopTimer();
        this.settings={ sound:true,haptic:true,trail:true,sensitivity:50,autoPause:true };
        this.startButton.style.display='block'; this.startButton.textContent='START GAME';
        document.getElementById('menuButtons').style.display='none';
        document.getElementById('skipLevelHint').classList.remove('show');
        document.getElementById('skipButton').style.display='none';
        this.setupLevel(); this.updateUI();
        document.getElementById('saveStatus').textContent='Progress reset';
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  SAVE / LOAD / ACHIEVEMENTS
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    saveGame() {
        try {
            localStorage.setItem('tiltSphereSave', JSON.stringify({
                level:this.level, score:this.score, achievements:this.achievements,
                timestamp:Date.now(), version:'3.0'
            }));
            const ind = document.getElementById('saveIndicator');
            ind.classList.add('show');
            setTimeout(() => ind.classList.remove('show'), 2000);
            document.getElementById('saveStatus').textContent = `Last saved: ${new Date().toLocaleTimeString()}`;
        } catch(e) {
            document.getElementById('saveStatus').textContent = 'Save failed ‚Äî storage full?';
        }
    }

    loadGame() {
        try {
            const raw = localStorage.getItem('tiltSphereSave');
            if (raw) {
                const d = JSON.parse(raw);
                this.level=d.level||1; this.score=d.score||0; this.achievements=d.achievements||[];
                document.getElementById('saveStatus').textContent = `Loaded: ${new Date(d.timestamp).toLocaleString()}`;
            }
        } catch(e) {
            document.getElementById('saveStatus').textContent = 'Failed to load save';
        }
    }

    checkAchievements() {
        const n = [];
        const push = name => { if (!this.achievements.includes(name)) { n.push(name); this.achievements.push(name); } };

        if (this.level === 2) push('first_win');
        [10,25,50,75,100,125,150,175,200,225,250].forEach(m => { if (this.level===m+1) push(`level_${m}`); });
        [{l:21,n:'tier_easy'},{l:41,n:'tier_medium'},{l:61,n:'tier_hard'},{l:81,n:'tier_expert'},{l:101,n:'tier_legendary'},{l:151,n:'tier_master'},{l:201,n:'tier_grandmaster'},{l:251,n:'tier_ultimate'}]
            .forEach(t => { if (this.level===t.l) push(t.n); });
        [{s:5000,n:'score_5k'},{s:10000,n:'score_10k'},{s:25000,n:'score_25k'},{s:50000,n:'score_50k'},{s:100000,n:'score_100k'}]
            .forEach(a => { if (this.score>=a.s) push(a.n); });

        if (n.length) {
            try { localStorage.setItem('tiltSphereAchievements', JSON.stringify(this.achievements)); } catch(e) {}
            this.showAchievementNotification(n[0]);
            n.slice(1).forEach((a,i) => setTimeout(()=>this.showAchievementNotification(a),(i+1)*5000));
        }
    }

    getAchievementData(name) {
        return ({
            first_win:        {title:'üéâ First Victory!',        description:'Completed your first level!'},
            level_10:         {title:'üîü Ten Levels Down!',       description:'Reached level 10'},
            level_25:         {title:'üåü Quarter Century!',       description:'Reached level 25'},
            level_50:         {title:'‚≠ê Halfway There!',         description:'Reached level 50'},
            level_75:         {title:'üí´ Three Quarters!',        description:'Reached level 75'},
            level_100:        {title:'üíØ Century Mark!',          description:'Reached level 100'},
            level_125:        {title:'üöÄ Beyond Limits!',         description:'Reached level 125'},
            level_150:        {title:'‚ö° Lightning Fast!',        description:'Reached level 150'},
            level_175:        {title:'üåà Almost There!',          description:'Reached level 175'},
            level_200:        {title:'üèÜ Legendary Status!',      description:'Reached level 200'},
            level_225:        {title:'üëë Royal Achievement!',     description:'Reached level 225'},
            level_250:        {title:'üéØ Perfect Score!',         description:'Completed all 250 levels!'},
            tier_easy:        {title:'üü¢ Easy Tier Complete!',    description:'Mastered the basics'},
            tier_medium:      {title:'üü° Medium Tier Complete!',  description:'Building skills'},
            tier_hard:        {title:'üü† Hard Tier Complete!',    description:'Getting challenging'},
            tier_expert:      {title:'üî¥ Expert Tier Complete!',  description:'Expert level achieved'},
            tier_legendary:   {title:'üü£ Legendary Tier Complete!', description:'Legendary skills'},
            tier_master:      {title:'‚ö´ Master Tier Complete!',  description:'Master level reached'},
            tier_grandmaster: {title:'üîµ Grandmaster!',           description:'Grandmaster achieved'},
            tier_ultimate:    {title:'‚ö™ Ultimate Tier Complete!', description:'Ultimate mastery!'},
            score_5k:         {title:'üí∞ 5K Points!',             description:'Scored 5,000 points'},
            score_10k:        {title:'üíé 10K Points!',            description:'Scored 10,000 points'},
            score_25k:        {title:'üèÖ 25K Points!',            description:'Scored 25,000 points'},
            score_50k:        {title:'ü•à 50K Points!',            description:'Scored 50,000 points'},
            score_100k:       {title:'ü•á 100K Points!',           description:'Scored 100,000 points'},
        })[name];
    }

    showAchievementNotification(name) {
        const d = this.getAchievementData(name); if (!d) return;
        document.getElementById('achievementTitle').textContent       = d.title;
        document.getElementById('achievementDescription').textContent = d.description;
        const el = document.getElementById('achievementNotification');
        el.classList.add('show');
        setTimeout(() => el.classList.remove('show'), 4000);
        if (this.settings.haptic && navigator.vibrate) navigator.vibrate([200,100,200]);
    }

    showNotification(title, desc, duration=3000) {
        const el = document.createElement('div');
        el.className = 'achievement-notification';
        el.innerHTML = `<div class="achievement-title">${title}</div><div class="achievement-description">${desc}</div>`;
        document.body.appendChild(el);
        setTimeout(() => el.classList.add('show'), 100);
        setTimeout(() => { el.classList.remove('show'); setTimeout(()=>el.remove(),500); }, duration);
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  UI HELPERS
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    updateUI() {
        document.getElementById('level').textContent            = this.level;
        document.getElementById('score').textContent            = this.score;
        document.getElementById('bestScore').textContent        = this.bestScore;
        document.getElementById('achievementCount').textContent = this.achievements.length;
        document.getElementById('livesCount').textContent       = this.lives;
        const pct = Math.min((this.level/this.levelConfigs.length)*100,100);
        document.getElementById('progressLevel').textContent = Math.round(pct)+'%';
        document.getElementById('progressFill').style.width  = pct+'%';
    }

    updateDifficultyBadge(d) {
        const b = document.getElementById('difficultyBadge');
        b.className = `difficulty-badge difficulty-${d}`;
        b.textContent = d.toUpperCase();
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  SETTINGS
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    showSettings() {
        document.getElementById('sensitivitySlider').value      = this.settings.sensitivity;
        document.getElementById('sensitivityValue').textContent = this.settings.sensitivity;
        document.getElementById('soundToggle').checked          = this.settings.sound;
        document.getElementById('hapticToggle').checked         = this.settings.haptic;
        document.getElementById('trailToggle').checked          = this.settings.trail;
        document.getElementById('autoPauseToggle').checked      = this.settings.autoPause;
        const sl = document.getElementById('sensitivitySlider');
        sl.oninput = () => document.getElementById('sensitivityValue').textContent = sl.value;
        document.getElementById('settingsModal').style.display = 'flex';
    }

    closeSettings() { document.getElementById('settingsModal').style.display='none'; }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  TIMER
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    startTimer() {
        this.stopTimer();
        const cfg = this.getCurrentConfig();
        // Time scales: easy=40s, medium=35s, hard=28s, expert=22s, legendary+=18s
        const timeLimits = { easy:40, medium:35, hard:28, expert:22, legendary:18, master:16, grandmaster:15, ultimate:14 };
        this.timeLeft = timeLimits[cfg.difficulty] || 30;
        this.updateTimerUI();
        this.timerRunning = true;
        this._timerInterval = setInterval(() => {
            if (!this.gameRunning || this.gamePaused || !this.timerRunning) return;
            this.timeLeft--;
            this.updateTimerUI();
            if (this.timeLeft <= 0) {
                this.stopTimer();
                this.loseLife('Time's up!');
            }
        }, 1000);
    }

    stopTimer() {
        if (this._timerInterval) { clearInterval(this._timerInterval); this._timerInterval = null; }
        this.timerRunning = false;
    }

    updateTimerUI() {
        const el = document.getElementById('timerCount');
        if (el) {
            el.textContent = this.timeLeft;
            el.style.color = this.timeLeft <= 5 ? '#f56565' : this.timeLeft <= 10 ? '#f6ad55' : '#fff';
        }
    }

    loseLife(reason) {
        this.lives = Math.max(0, this.lives - 1);
        this.combo = 0;
        document.getElementById('livesCount').textContent = this.lives;
        if (this.settings.haptic && navigator.vibrate) navigator.vibrate([200,100,200,100,400]);
        this.spawnParticles(this.ballX+10, this.ballY+10, '#f56565', 20);

        if (this.lives <= 0) {
            this.triggerGameOver(reason);
        } else {
            this.showNotification(`üíî Life lost! ‚Äî ${reason}`, `${this.lives} ${this.lives===1?'life':'lives'} remaining`, 2500);
            // Reset ball and restart timer
            this.ballX = 165; this.ballY = 165;
            this.ballVelX = 0; this.ballVelY = 0;
            this.startTimer();
        }
    }

    triggerGameOver(reason) {
        this.gameRunning   = false;
        this.levelCompleting = false;
        this.stopTimer();
        this.gameOverActive = true;
        this.saveHighScore();
        // Populate modal
        document.getElementById('gameOverMsg').textContent  = reason;
        document.getElementById('gameOverScore').textContent = this.score;
        document.getElementById('gameOverLevel').textContent = this.level;
        document.getElementById('gameOverBest').textContent  = this.bestScore;
        document.getElementById('gameOverModal').style.display = 'flex';
        if (this.settings.haptic && navigator.vibrate) navigator.vibrate([400,100,400]);
    }

    restartGame() {
        document.getElementById('gameOverModal').style.display = 'none';
        this.gameOverActive = false;
        this.level = 1; this.score = 0; this.lives = 3; this.combo = 0;
        this.setupLevel();
        this.updateUI();
        this.startTimer();
        this.gameRunning = true;
        this.levelIntroLevel    = this.level;
        this.levelIntroProgress = 0.001;
        this.levelIntroActive   = true;
        this.tutorialActive = (this.level === 1);
        this.tutorialProgress = 0;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  LEADERBOARD
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    saveHighScore() {
        try {
            const scores = JSON.parse(localStorage.getItem('tiltSphereScores') || '[]');
            scores.push({ score: this.score, level: this.level, date: new Date().toLocaleDateString() });
            scores.sort((a,b) => b.score - a.score);
            scores.splice(5); // keep top 5
            localStorage.setItem('tiltSphereScores', JSON.stringify(scores));
            if (this.score > this.bestScore) {
                this.bestScore = this.score;
                localStorage.setItem('tiltSphereBest', this.bestScore.toString());
            }
        } catch(e) {}
    }

    showLeaderboard() {
        const scores = JSON.parse(localStorage.getItem('tiltSphereScores') || '[]');
        const list   = document.getElementById('leaderboardList');
        if (!scores.length) {
            list.innerHTML = '<div style="opacity:.6">No scores yet ‚Äî play a game!</div>';
        } else {
            const medals = ['ü•á','ü•à','ü•â','4Ô∏è‚É£','5Ô∏è‚É£'];
            list.innerHTML = scores.map((s,i) =>
                `<div>${medals[i]} <b>${s.score.toLocaleString()}</b> pts &nbsp;¬∑&nbsp; Lvl ${s.level} &nbsp;¬∑&nbsp; <span style="opacity:.6">${s.date}</span></div>`
            ).join('');
        }
        document.getElementById('leaderboardModal').style.display = 'flex';
    }

    closeLeaderboard() {
        document.getElementById('leaderboardModal').style.display = 'none';
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  COMBO MULTIPLIER
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    getComboMultiplier() {
        if (this.combo <= 0)  return 1;
        if (this.combo <= 2)  return 1.5;
        if (this.combo <= 5)  return 2;
        if (this.combo <= 9)  return 3;
        return 5;
    }

    showComboPopup(multiplier, x, y) {
        if (multiplier <= 1) return;
        const labels = { 1.5:'x1.5 COMBO!', 2:'x2 COMBO!', 3:'x3 HOT STREAK!', 5:'x5 ON FIRE! üî•' };
        this.scorePopups.push({
            x, y: y - 35,
            text: labels[multiplier] || `x${multiplier}`,
            life: 80, maxLife: 80,
            color: multiplier >= 3 ? '#ffd700' : '#4fd1c7'
        });
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  TILT CALIBRATION
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    startCalibration() {
        this.calibrating       = true;
        this.calibrationSamples = [];
        this.calibrationDone   = false;
        // Collect 60 samples (1 second) then average
        const handler = (e) => {
            if (!this.calibrating) return;
            this.calibrationSamples.push({ beta: e.beta||0, gamma: e.gamma||0 });
            if (this.calibrationSamples.length >= 60) {
                window.removeEventListener('deviceorientation', handler);
                const avgBeta  = this.calibrationSamples.reduce((s,v)=>s+v.beta, 0)  / 60;
                const avgGamma = this.calibrationSamples.reduce((s,v)=>s+v.gamma, 0) / 60;
                this.tiltOffsetBeta  = avgBeta;
                this.tiltOffsetGamma = avgGamma;
                this.calibrating     = false;
                this.calibrationDone = true;
                this.finishCalibrationAndStart();
            }
        };
        window.addEventListener('deviceorientation', handler);
    }

    finishCalibrationAndStart() {
        this.gameRunning = true; this.gamePaused = false; this.levelCompleting = false;
        this.startButton.style.display = 'none';
        document.getElementById('menuButtons').style.display = 'flex';
        window.addEventListener('deviceorientation', e => this.handleOrientation(e));
        window.addEventListener('keydown', e => this.handleKeyboard(e));
        this.lives = 3; this.combo = 0;
        document.getElementById('livesCount').textContent = this.lives;
        // Show joystick if gyro not detected
        this.joystickActive = !this.gyroAvailable;
        this.startTimer();
        this.levelIntroLevel    = this.level;
        this.levelIntroProgress = 0.001;
        this.levelIntroActive   = true;
        this.tutorialActive     = (this.level === 1);
        this.tutorialProgress   = 0;
    }

    drawJoystick(ctx) {
        const bx = this.joystickBase.x,  by = this.joystickBase.y;
        const tx = this.joystickThumb.x, ty = this.joystickThumb.y;
        const active = this.joystickTouchId !== null;
        ctx.save();
        ctx.globalAlpha = active ? 0.75 : 0.35;
        // Base ring
        ctx.strokeStyle = '#63b3ed'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(bx, by, 38, 0, Math.PI*2); ctx.stroke();
        // Inner guide ring
        ctx.strokeStyle = 'rgba(99,179,237,0.3)'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(bx, by, 20, 0, Math.PI*2); ctx.stroke();
        // Thumb
        const tg = ctx.createRadialGradient(tx-3,ty-3,1,tx,ty,14);
        tg.addColorStop(0, '#fff');
        tg.addColorStop(1, '#63b3ed');
        ctx.fillStyle = tg;
        ctx.beginPath(); ctx.arc(tx, ty, 14, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    }

    drawCalibrationScreen(ctx) {
        const p = Math.min(this.calibrationSamples.length / 60, 1);
        ctx.save();
        // Dim background
        ctx.fillStyle = 'rgba(0,0,0,0.75)';
        ctx.fillRect(0, 0, this.W, this.H);
        // Title
        ctx.textAlign    = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle    = '#63b3ed';
        ctx.font         = 'bold 16px Arial';
        ctx.shadowColor  = '#63b3ed'; ctx.shadowBlur = 10;
        ctx.fillText('CALIBRATING TILT‚Ä¶', this.W/2, this.H/2 - 50);
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.font      = '12px Arial'; ctx.shadowBlur = 0;
        ctx.fillText('Hold your device still', this.W/2, this.H/2 - 28);
        // Progress bar
        ctx.strokeStyle = '#63b3ed'; ctx.lineWidth = 2;
        ctx.strokeRect(this.W/2-70, this.H/2-8, 140, 16);
        ctx.fillStyle = '#63b3ed';
        ctx.fillRect(this.W/2-68, this.H/2-6, 136*p, 12);
        // Percentage
        ctx.fillStyle = '#fff'; ctx.font = 'bold 13px Arial';
        ctx.fillText(`${Math.round(p*100)}%`, this.W/2, this.H/2+22);
        ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  BACKGROUND THEME
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    getBgTargetColour() {
        const cfg = this.getCurrentConfig();
        const themes = {
            easy:        { r:28, g:45, b:55  },  // cool teal-dark
            medium:      { r:45, g:38, b:20  },  // amber dark
            hard:        { r:50, g:25, b:25  },  // red dark
            expert:      { r:35, g:20, b:55  },  // purple dark
            legendary:   { r:55, g:45, b:10  },  // gold dark
            master:      { r:55, g:18, b:18  },  // deep red
            grandmaster: { r:10, g:20, b:55  },  // deep blue
            ultimate:    { r:8,  g:8,  b:8   },  // near black
        };
        return themes[cfg.difficulty] || { r:28, g:36, b:48 };
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  TUTORIAL DRAW
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    drawTutorial(ctx) {
        const alpha = 1 - this.tutorialProgress;
        if (alpha <= 0) return;
        ctx.save();
        ctx.globalAlpha = alpha * 0.85;

        // Pulsing arrows pointing in 4 tilt directions
        const arrowSize = 22;
        const cx = this.W/2, cy = this.H/2;
        const offsets = [
            { dx: 0,   dy:-55, angle: -Math.PI/2, label:'Tilt back' },
            { dx: 0,   dy: 55, angle:  Math.PI/2, label:'Tilt forward' },
            { dx:-55,  dy:  0, angle:  Math.PI,   label:'Tilt left' },
            { dx: 55,  dy:  0, angle:  0,          label:'Tilt right' },
        ];
        const pulse = 0.7 + Math.sin(this.time * 4) * 0.3;
        offsets.forEach(o => {
            ctx.save();
            ctx.translate(cx + o.dx, cy + o.dy);
            ctx.rotate(o.angle);
            ctx.scale(pulse, pulse);
            ctx.fillStyle = '#63b3ed';
            ctx.shadowColor = '#63b3ed'; ctx.shadowBlur = 12;
            ctx.beginPath();
            ctx.moveTo(arrowSize, 0);
            ctx.lineTo(-arrowSize*0.6,  arrowSize*0.6);
            ctx.lineTo(-arrowSize*0.6, -arrowSize*0.6);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        });

        // Centred hint text
        ctx.fillStyle    = 'rgba(255,255,255,0.9)';
        ctx.font         = 'bold 12px Arial';
        ctx.textAlign    = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor  = '#000'; ctx.shadowBlur = 6;
        ctx.fillText('Tilt to move the ball', cx, cy + 80);
        ctx.restore();
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  DAILY CHALLENGE
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    getDailyDateString() {
        const d = new Date();
        return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    }

    getDailySeed(dateStr) {
        // Simple string hash ‚Üí deterministic seed
        let h = 0;
        for (let i = 0; i < dateStr.length; i++) h = Math.imul(31, h) + dateStr.charCodeAt(i) | 0;
        return Math.abs(h);
    }

    startDailyChallenge() {
        if (!this.gameRunning) return;
        this.dailyDate  = this.getDailyDateString();
        this.dailySeed  = this.getDailySeed(this.dailyDate);
        const saved     = JSON.parse(localStorage.getItem('tiltSphereDailyScores') || '{}');
        const todayBest = saved[this.dailyDate];
        document.getElementById('dailyDateLabel').textContent = this.dailyDate;
        document.getElementById('dailyBestScore').textContent = todayBest
            ? `Your best today: ${todayBest.score} pts (level ${todayBest.level})`
            : 'No score yet today ‚Äî go for it!';
        document.getElementById('dailyModal').style.display = 'flex';
    }

    closeDailyModal() { document.getElementById('dailyModal').style.display = 'none'; }

    confirmDailyChallenge() {
        this.closeDailyModal();
        this.gameMode   = 'daily';
        this.level      = 1;
        this.score      = 0;
        this.lives      = 3;
        this.combo      = 0;
        this._rng       = this._seededRng(this.dailySeed);
        this.setupLevel();
        this.updateUI();
        this.startTimer();
        this.levelIntroLevel    = 1;
        this.levelIntroProgress = 0.001;
        this.levelIntroActive   = true;
        this.showNotification('üìÖ Daily Challenge!', `Seed: ${this.dailyDate}`, 2500);
    }

    saveDailyScore() {
        try {
            const saved = JSON.parse(localStorage.getItem('tiltSphereDailyScores') || '{}');
            const prev  = saved[this.dailyDate];
            if (!prev || this.score > prev.score) {
                saved[this.dailyDate] = { score: this.score, level: this.level };
                localStorage.setItem('tiltSphereDailyScores', JSON.stringify(saved));
            }
        } catch(e) {}
    }

    // Seeded PRNG (mulberry32)
    _seededRng(seed) {
        let s = seed >>> 0;
        return () => {
            s += 0x6D2B79F5;
            let t = Math.imul(s ^ (s >>> 15), 1 | s);
            t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
            return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  ENDLESS MODE
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    startEndlessMode() {
        if (!this.gameRunning) return;
        this.gameMode     = 'endless';
        this.endlessLevel = 1;
        this.level        = 1;
        this.score        = 0;
        this.lives        = 3;
        this.combo        = 0;
        this.setupLevel();
        this.updateUI();
        this.startTimer();
        this.levelIntroLevel    = 1;
        this.levelIntroProgress = 0.001;
        this.levelIntroActive   = true;
        this.showNotification('‚ôæÔ∏è Endless Mode!', 'How far can you go?', 2500);
    }

    getEndlessConfig() {
        // Procedurally scale difficulty beyond level 250
        const n = this.endlessLevel;
        return {
            funnelSize:      Math.max(30 - Math.floor(n/20), 18),
            obstacles:       Math.min(8 + Math.floor(n/3), 50),
            movingObstacles: Math.min(3 + Math.floor(n/5), 20),
            ballSpeed:       Math.min(1.5 + n * 0.015, 4),
            difficulty:      n < 10 ? 'hard' : n < 25 ? 'expert' : n < 50 ? 'legendary' : n < 100 ? 'master' : 'ultimate',
            specialMechanic: 'endless'
        };
    }

    saveEndlessScore() {
        try {
            const scores = JSON.parse(localStorage.getItem('tiltSphereEndlessScores') || '[]');
            scores.push({ score: this.score, level: this.endlessLevel, date: new Date().toLocaleDateString() });
            scores.sort((a,b) => b.score - a.score);
            scores.splice(5);
            localStorage.setItem('tiltSphereEndlessScores', JSON.stringify(scores));
        } catch(e) {}
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  BALL SKINS
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    getSkinDefs() {
        return [
            { id:0, name:'Classic',  color:'#fc8181', unlockAchievement:null,        emoji:'üî¥' },
            { id:1, name:'Ocean',    color:'#63b3ed', unlockAchievement:'tier_easy',  emoji:'üîµ' },
            { id:2, name:'Forest',   color:'#68d391', unlockAchievement:'tier_hard',  emoji:'üü¢' },
            { id:3, name:'Gold',     color:'#ffd700', unlockAchievement:'tier_legendary', emoji:'üü°' },
            { id:4, name:'Plasma',   color:'#b794f4', unlockAchievement:'tier_master', emoji:'üü£' },
        ];
    }

    showSkinPicker() {
        const grid  = document.getElementById('skinGrid');
        const skins = this.getSkinDefs();
        grid.innerHTML = skins.map(s => {
            const unlocked = s.unlockAchievement === null || this.achievements.includes(s.unlockAchievement);
            const active   = this.activeSkin === s.id;
            return `<div onclick="game.selectSkin(${s.id})" style="
                cursor:${unlocked?'pointer':'default'};
                padding:10px 6px; border-radius:10px; text-align:center;
                border:2px solid ${active?'#ffd700':'rgba(255,255,255,0.15)'};
                background:${active?'rgba(255,215,0,0.1)':'rgba(255,255,255,0.04)'};
                opacity:${unlocked?1:0.4};">
                <div style="font-size:24px">${s.emoji}</div>
                <div style="font-size:10px;margin-top:4px">${s.name}</div>
                <div style="font-size:9px;opacity:.6">${unlocked?'‚úì Unlocked':'Locked'}</div>
            </div>`;
        }).join('');
        document.getElementById('skinModal').style.display = 'flex';
    }

    selectSkin(id) {
        const skins   = this.getSkinDefs();
        const skin    = skins.find(s => s.id === id);
        if (!skin) return;
        const unlocked = skin.unlockAchievement === null || this.achievements.includes(skin.unlockAchievement);
        if (!unlocked) { this.showNotification('üîí Locked', `Earn the ${skin.unlockAchievement} achievement`, 2500); return; }
        this.activeSkin = id;
        try { localStorage.setItem('tiltSphereSkin', id.toString()); } catch(e) {}
        this.showSkinPicker(); // refresh grid
    }

    closeSkinPicker() { document.getElementById('skinModal').style.display = 'none'; }

    saveSettings() {
        this.settings.sensitivity = parseInt(document.getElementById('sensitivitySlider').value);
        this.settings.sound       = document.getElementById('soundToggle').checked;
        this.settings.haptic      = document.getElementById('hapticToggle').checked;
        this.settings.trail       = document.getElementById('trailToggle').checked;
        this.settings.autoPause   = document.getElementById('autoPauseToggle').checked;
        try {
            localStorage.setItem('tiltSphereSettings', JSON.stringify(this.settings));
            this.closeSettings();
            document.getElementById('saveStatus').textContent='Settings saved!';
            setTimeout(()=>{ if(document.getElementById('saveStatus').textContent.includes('Settings saved!')) document.getElementById('saveStatus').textContent=''; },3000);
        } catch(e) { alert('Failed to save settings.'); }
    }
}

// ‚îÄ‚îÄ Service Worker registration (PWA) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js').catch(() => {});
    });
}

// ‚îÄ‚îÄ Always dismiss splash after 2s, regardless of game init status ‚îÄ‚îÄ
setTimeout(() => {
    const splash = document.getElementById('splashScreen');
    if (splash) {
        splash.classList.add('fade-out');
        setTimeout(() => { splash.style.display = 'none'; }, 600);
    }
}, 2000);

// ‚îÄ‚îÄ Boot ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let game;
document.addEventListener('DOMContentLoaded', () => {
    try {
        game = new TiltBallGame();
    } catch(e) {
        console.error(e);
        document.body.innerHTML = `<div style="color:#fff;text-align:center;padding:50px"><h2>Game Failed to Load</h2><p>Please refresh.</p><p style="font-size:12px;margin-top:20px">Error: ${e.message}</p></div>`;
    }
});
</script>

</body>
</html>