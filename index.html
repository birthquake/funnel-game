<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>TiltSphere - Ultimate Ball Challenge</title>
    <style>
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
            overflow: hidden;
        }

        body {
            background: linear-gradient(135deg, #0f0f23, #1a1a2e, #16213e, #0f3460);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            font-family: 'Arial', sans-serif;
            color: #ffffff;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Header styles */
        .header {
            text-align: center;
            margin-bottom: 10px;
            z-index: 50;
        }

        .title {
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(99, 179, 237, 0.8);
            margin-bottom: 5px;
            background: linear-gradient(45deg, #63b3ed, #4fd1c7, #68d391);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stats {
            display: flex;
            gap: 15px;
            font-size: 14px;
            margin-bottom: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .stat-item {
            padding: 3px 8px;
            background: rgba(99, 179, 237, 0.1);
            border-radius: 10px;
            border: 1px solid rgba(99, 179, 237, 0.3);
        }

        .progress-meter {
            width: 200px;
            height: 12px;
            background: #333;
            border: 1px solid #63b3ed;
            margin: 10px auto;
            border-radius: 6px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #68d391, #4fd1c7, #63b3ed);
            width: 0%;
            transition: width 0.5s ease;
        }

        /* Level preview styles */
        .level-preview {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #63b3ed;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            z-index: 100;
            min-width: 250px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .level-preview.show {
            opacity: 1;
        }

        .level-preview h3 {
            color: #63b3ed;
            margin-bottom: 10px;
        }

        .level-preview-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 14px;
        }

        /* Achievement notification styles */
        .achievement-notification {
            position: fixed;
            top: 20px;
            right: -400px;
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #000;
            padding: 15px 20px;
            border-radius: 10px;
            border: 2px solid #ffd700;
            font-weight: bold;
            z-index: 200;
            transition: right 0.5s ease;
            max-width: 300px;
            box-shadow: 0 4px 20px rgba(255, 215, 0, 0.4);
        }

        .achievement-notification.show {
            right: 20px;
        }

        .achievement-title {
            font-size: 16px;
            margin-bottom: 5px;
        }

        .achievement-description {
            font-size: 12px;
            opacity: 0.8;
        }

        /* Difficulty badges */
        .difficulty-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            margin-left: 8px;
        }

        .difficulty-easy { background: #68d391; color: #000; }
        .difficulty-medium { background: #f6ad55; color: #000; }
        .difficulty-hard { background: #f56565; color: #fff; }
        .difficulty-expert { background: #9f7aea; color: #fff; }
        .difficulty-legendary { background: #ffd700; color: #000; }
        .difficulty-master { background: #e53e3e; color: #fff; }
        .difficulty-grandmaster { background: #1a365d; color: #fff; }
        .difficulty-ultimate { background: #000000; color: #ffd700; }

        /* Game container styles */
        .game-container {
            position: relative;
            width: 350px;
            height: 350px;
            background: radial-gradient(circle at center, #2d3748, #1a202c);
            border: 3px solid #63b3ed;
            border-radius: 20px;
            box-shadow: 
                0 0 30px rgba(99, 179, 237, 0.4),
                inset 0 0 30px rgba(99, 179, 237, 0.1);
            overflow: hidden;
        }

        /* Ball styles */
        .ball {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle at 30% 30%, #ffffff, #f56565, #e53e3e);
            border-radius: 50%;
            box-shadow: 
                0 0 20px rgba(245, 101, 101, 0.8),
                inset -3px -3px 8px rgba(0, 0, 0, 0.4),
                inset 2px 2px 4px rgba(255, 255, 255, 0.3);
                transition: transform 0.1s ease-out, opacity 0.1s ease-out;            
            z-index: 10;
            left: 165px;
            top: 165px;
        }

        /* Ball trail effects */
        .ball-trail {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(245, 101, 101, 0.6), transparent);
            pointer-events: none;
            z-index: 5;
            opacity: 0.7;
        }

        /* Target funnel styles */
        .funnel {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle at center, #38a169, #48bb78, #68d391);
            box-shadow: 
                0 0 25px rgba(104, 211, 145, 0.8),
                inset 0 0 15px rgba(0, 0, 0, 0.5);
            border: 2px solid #68d391;
            animation: funnelPulse 2s ease-in-out infinite;
            left: 250px;
            top: 250px;
        }

        @keyframes funnelPulse {
            0%, 100% { 
                box-shadow: 0 0 25px rgba(104, 211, 145, 0.8), inset 0 0 15px rgba(0, 0, 0, 0.5); 
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 40px rgba(104, 211, 145, 1), inset 0 0 15px rgba(0, 0, 0, 0.5); 
                transform: scale(1.05);
            }
        }

        /* Obstacle styles */
        .obstacle {
            position: absolute;
            background: linear-gradient(45deg, #744210, #975a16);
            border: 1px solid #d69e2e;
            box-shadow: 0 0 15px rgba(214, 158, 46, 0.4);
        }

        .moving-obstacle {
            background: linear-gradient(45deg, #553c9a, #6b46c1);
            border: 1px solid #9f7aea;
            box-shadow: 0 0 15px rgba(159, 122, 234, 0.4);
        }

        /* Particle effects */
        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 15;
        }
        /* Control styles */
        .controls {
            text-align: center;
            margin-top: 15px;
            font-size: 12px;
            max-width: 350px;
            z-index: 50;
        }

        .start-button, .menu-button {
            background: linear-gradient(45deg, #63b3ed, #4fd1c7);
            border: none;
            color: white;
            padding: 12px 24px;
            font-family: inherit;
            cursor: pointer;
            margin: 8px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(99, 179, 237, 0.3);
            transition: all 0.3s ease;
        }

        .start-button:hover, .menu-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(99, 179, 237, 0.4);
        }

        .menu-button {
            font-size: 12px;
            padding: 8px 16px;
            background: linear-gradient(45deg, #4a5568, #63b3ed);
        }

        .menu-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Animation utilities */
        .pulse {
            animation: pulse 0.5s ease;
        }

        .shake {
            animation: shake 0.3s ease;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); box-shadow: 0 0 40px rgba(99, 179, 237, 0.8); }
            100% { transform: scale(1); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* Moving obstacle animations */
        @keyframes movingObstacle {
            0% { transform: translateX(0); }
            50% { transform: translateX(80px); }
            100% { transform: translateX(0); }
        }

        .obstacle.moving {
            animation: movingObstacle 4s ease-in-out infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .obstacle.rotating {
            animation: rotate 6s linear infinite;
        }

        /* Particle explosion effects */
        @keyframes particleExplosion {
            0% {
                opacity: 1;
                transform: scale(1) translateX(0) translateY(0);
            }
            100% {
                opacity: 0;
                transform: scale(0.2) translateX(var(--dx)) translateY(var(--dy));
            }
        }

        .particle-explosion {
            animation: particleExplosion 0.8s ease-out forwards;
        }

        /* Save indicator */
        .save-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(104, 211, 145, 0.2);
            border: 1px solid #68d391;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 10px;
            color: #68d391;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .save-indicator.show {
            opacity: 1;
        }

        /* Paused overlay */
        .paused-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 150;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .paused-overlay.show {
            opacity: 1;
            pointer-events: all;
        }

        .paused-content {
            text-align: center;
            color: white;
        }

        .paused-content h2 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #63b3ed;
        }

        /* Skip level button styles */
        .skip-level-hint {
            font-size: 10px;
            color: #f6ad55;
            margin-top: 5px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .skip-level-hint.show {
            opacity: 1;
        }

        /* Emergency center button */
/*
.emergency-center {
    position: absolute;
    bottom: 10px;
    left: 10px;
    background: rgba(245, 101, 101, 0.2);
    border: 1px solid #f56565;
    color: #f56565;
    padding: 5px 10px;
    border-radius: 15px;
    font-size: 10px;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.emergency-center.show {
    opacity: 1;
}

.emergency-center:hover {
    background: rgba(245, 101, 101, 0.4);
}
*/

        /* Collision feedback styles */
        .collision-wall {
            animation: wallCollisionFeedback 0.3s ease;
        }

        .collision-obstacle {
            animation: obstacleCollisionFeedback 0.3s ease;
        }

        @keyframes wallCollisionFeedback {
            0% { border-color: #63b3ed; }
            50% { border-color: #f56565; box-shadow: 0 0 30px rgba(245, 101, 101, 0.6); }
            100% { border-color: #63b3ed; }
        }

        @keyframes obstacleCollisionFeedback {
            0% { filter: brightness(1); }
            50% { filter: brightness(1.5) saturate(1.5); }
            100% { filter: brightness(1); }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">TILTSPHERE</div>
        <div class="stats">
            <div class="stat-item">Level: <span id="level">1</span><span id="difficultyBadge" class="difficulty-badge difficulty-easy">EASY</span></div>
            <div class="stat-item">Score: <span id="score">0</span></div>
            <div class="stat-item">Best: <span id="bestScore">0</span></div>
        </div>
        <div class="progress-meter">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div style="font-size: 10px;">Progress: <span id="progressLevel">0%</span> • <span id="achievementCount">0</span> achievements</div>
    </div>

    <!-- Level Preview -->
    <div class="level-preview" id="levelPreview">
        <h3>Level <span id="previewLevel"></span></h3>
        <div class="level-preview-stats">
            <div>Difficulty: <span id="previewDifficulty"></span></div>
            <div>Obstacles: <span id="previewObstacles"></span></div>
            <div>Target Size: <span id="previewFunnelSize"></span></div>
        </div>
    </div>

    <!-- Achievement Notification -->
    <div class="achievement-notification" id="achievementNotification">
        <div class="achievement-title" id="achievementTitle"></div>
        <div class="achievement-description" id="achievementDescription"></div>
    </div>

    <div class="game-container" id="gameContainer">
        <div class="ball" id="ball"></div>
        <div class="funnel" id="funnel"></div>
        <div class="save-indicator" id="saveIndicator">Progress Saved!</div>
<!-- <div class="emergency-center" id="emergencyCenter">Double-tap to center ball</div> -->        
        <!-- Paused Overlay -->
        <div class="paused-overlay" id="pausedOverlay">
            <div class="paused-content">
                <h2>PAUSED</h2>
                <p>Click anywhere to resume</p>
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="start-button" id="startButton">START GAME</button>
        <div class="menu-buttons" id="menuButtons" style="display: none;">
            <button class="menu-button" onclick="game.pauseGame()">Pause</button>
            <button class="menu-button" onclick="game.saveGame()">Save</button>
            <button class="menu-button" onclick="game.showSettings()">Settings</button>
            <button class="menu-button" onclick="game.resetProgress()">Reset</button>
            <button class="menu-button" id="skipButton" onclick="game.skipLevel()" style="display: none;">Skip Level</button>
        </div>
        
        <div>Tilt your device to guide the ball into the target</div>
        <div class="skip-level-hint" id="skipLevelHint">Having trouble? Skip available after 10 attempts</div>
        <div style="margin-top: 5px; font-size: 10px;" id="saveStatus"></div>
    </div>
    <!-- Settings Modal -->
    <div id="settingsModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 100; align-items: center; justify-content: center;">
        <div style="background: linear-gradient(135deg, #1a202c, #2d3748); border: 2px solid #63b3ed; border-radius: 15px; padding: 20px; width: 90%; max-width: 300px; color: white;">
            <h3 style="text-align: center; margin-bottom: 20px; color: #63b3ed;">Settings</h3>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">Sensitivity: <span id="sensitivityValue">50</span>%</label>
                <input type="range" id="sensitivitySlider" min="10" max="100" value="50" style="width: 100%;">
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="soundToggle" checked>
                    <span>Sound Effects</span>
                </label>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="hapticToggle" checked>
                    <span>Haptic Feedback</span>
                </label>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="trailToggle" checked>
                    <span>Ball Trail</span>
                </label>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="autoPauseToggle" checked>
                    <span>Auto-pause when window loses focus</span>
                </label>
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button onclick="game.saveSettings()" style="background: #68d391; color: black; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer;">Save</button>
                <button onclick="game.closeSettings()" style="background: #f56565; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer;">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        class TiltBallGame {
            constructor() {
                // DOM elements
                this.ball = document.getElementById('ball');
                this.funnel = document.getElementById('funnel');
                this.gameContainer = document.getElementById('gameContainer');
                this.startButton = document.getElementById('startButton');
                this.pausedOverlay = document.getElementById('pausedOverlay');
                this.emergencyCenter = document.getElementById('emergencyCenter');
                this.achievementNotification = document.getElementById('achievementNotification');
                this.levelPreview = document.getElementById('levelPreview');
                
                // Ball physics
                this.ballX = 165;
                this.ballY = 165;
                this.ballVelX = 0;
                this.ballVelY = 0;
                this.friction = 0.95;
                this.sensitivity = 0.5;
                this.maxVelocity = 8; // NEW: Velocity cap
                
                // Game state
                this.level = 1;
                this.score = 0;
                this.bestScore = parseInt(localStorage.getItem('tiltSphereBest') || '0');
                this.gameRunning = false;
                this.gamePaused = false;
                this.obstacles = [];
                this.particles = [];
                this.ballTrail = [];
                this.ballTrailElements = []; // NEW: Reusable trail elements
                this.achievements = JSON.parse(localStorage.getItem('tiltSphereAchievements') || '[]');
                this.levelAttempts = 0; // NEW: Track attempts for skip feature
                this.stuckTimer = 0; // NEW: Track if ball is stuck
                this.lastBallPosition = { x: 165, y: 165 };
                
                // CRITICAL: Race condition protection
                this.levelCompleting = false;
                
                // Game constants
                this.containerWidth = 350;
                this.containerHeight = 350;
                this.ballSize = 20;
                
                // NEW: Enhanced settings
                this.settings = {
                    sound: true,
                    haptic: true,
                    trail: true,
                    sensitivity: 50,
                    autoPause: true
                };
                
                // Load settings with error handling
                try {
                    const savedSettings = localStorage.getItem('tiltSphereSettings');
                    if (savedSettings) {
                        this.settings = { ...this.settings, ...JSON.parse(savedSettings) };
                    }
                } catch (error) {
                    console.warn('Failed to load settings:', error);
                }
                
                // Generate all 250 levels with proper funnel sizing
                this.levelConfigs = this.generateLevelConfigs();
                
                // Initialize
                this.loadGame();
                this.setupLevel();
                this.updateUI();
                this.setupEventListeners();
                
                // NEW: Auto-pause on window blur
                this.setupAutoPause();
                
                // NEW: Emergency center functionality
                // this.setupEmergencyCenter();
            }
            
            setupEventListeners() {
                this.startButton.addEventListener('click', () => this.requestPermission());
                
                // NEW: Paused overlay click to resume
                this.pausedOverlay.addEventListener('click', () => {
                    if (this.gamePaused) {
                        this.resumeGame();
                    }
                });
            }
            
            setupAutoPause() {
                // NEW: Auto-pause when window loses focus
                window.addEventListener('blur', () => {
                    if (this.gameRunning && !this.gamePaused && this.settings.autoPause) {
                        this.pauseGame(true); // true = auto-pause
                    }
                });
                
                window.addEventListener('focus', () => {
                    // Don't auto-resume, let user click to resume
                });
            }
            
            setupEmergencyCenter() {
                // NEW: Double-tap to center ball
                let tapCount = 0;
                let tapTimer = null;
                
                this.emergencyCenter.addEventListener('click', () => {
                    tapCount++;
                    
                    if (tapCount === 1) {
                        tapTimer = setTimeout(() => {
                            tapCount = 0;
                        }, 500);
                    } else if (tapCount === 2) {
                        clearTimeout(tapTimer);
                        tapCount = 0;
                        this.centerBall();
                    }
                });
            }
            
            centerBall() {
                // NEW: Emergency ball centering
                if (!this.gameRunning || this.gamePaused) return;
                
                this.ballX = 165;
                this.ballY = 165;
                this.ballVelX = 0;
                this.ballVelY = 0;
                
                // Visual feedback
                this.createParticles(this.ballX + this.ballSize/2, this.ballY + this.ballSize/2, '#4fd1c7', 12);
                this.gameContainer.classList.add('pulse');
                setTimeout(() => this.gameContainer.classList.remove('pulse'), 500);
                
                // Hide emergency button temporarily
                // this.emergencyCenter.classList.remove('show');
                this.stuckTimer = 0;
            }
            animateBallIntoFunnel(callback) {
    // Disable game physics during animation
    this.ballVelX = 0;
    this.ballVelY = 0;
    
    const config = this.getCurrentConfig();
    const funnelSize = Math.max(config.funnelSize, 30);
    const funnelCenterX = this.funnelX + funnelSize / 2;
    const funnelCenterY = this.funnelY + funnelSize / 2;
    
    // Animation parameters
    const startTime = Date.now();
    const duration = 1200; // 1.2 seconds
    const initialRadius = Math.sqrt(
        (this.ballX + this.ballSize/2 - funnelCenterX) ** 2 + 
        (this.ballY + this.ballSize/2 - funnelCenterY) ** 2
    );
    
    const animate = () => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        if (progress >= 1) {
            // Animation complete
            this.ball.style.transform = 'scale(0.1)';
            this.ball.style.opacity = '0.2';
            setTimeout(() => {
                this.ball.style.transform = 'scale(1)';
                this.ball.style.opacity = '1';
                callback();
            }, 200);
            return;
        }
        
        // Easing function for smooth deceleration
        const easeOut = 1 - Math.pow(1 - progress, 3);
        
        // Calculate spiral position
        const radius = initialRadius * (1 - easeOut);
        const angle = progress * Math.PI * 6; // 3 full rotations
        const scale = 1 - (progress * 0.7); // Shrink to 30% size
        
        // Position ball in spiral
        const spiralX = funnelCenterX + Math.cos(angle) * radius - this.ballSize/2;
        const spiralY = funnelCenterY + Math.sin(angle) * radius - this.ballSize/2;
        
        this.ballX = spiralX;
        this.ballY = spiralY;
        
        // Update visual position and scale
        this.ball.style.left = this.ballX + 'px';
        this.ball.style.top = this.ballY + 'px';
        this.ball.style.transform = `scale(${scale})`;
        this.ball.style.opacity = scale; // Fade as it shrinks
        
        // Create spiral trail particles
        if (Math.random() < 0.3) {
            this.createParticles(
                this.ballX + this.ballSize/2, 
                this.ballY + this.ballSize/2, 
                '#4fd1c7', 
                2
            );
        }
        
        requestAnimationFrame(animate);
    };
    
    animate();
}
            
            generateLevelConfigs() {
                const configs = [];
                
                // Levels 1-20: Learning (Easy) - Enhanced with better obstacle distribution
                for (let i = 1; i <= 20; i++) {
                    configs.push({
                        funnelSize: Math.max(60 - i * 2, 35),
                        obstacles: Math.min(2 + Math.floor(i / 3), 6),
                        timeLimit: 0,
                        movingObstacles: 0,
                        ballSpeed: 1 + (i * 0.02),
                        difficulty: 'easy',
                        specialMechanic: null
                    });
                }
                
                // Levels 21-40: Building Skills (Medium)
                for (let i = 21; i <= 40; i++) {
                    configs.push({
                        funnelSize: Math.max(35 - (i - 20) * 0.25, 30),
                        obstacles: Math.min(2 + Math.floor((i - 20) / 3), 6),
                        timeLimit: 0,
                        movingObstacles: Math.min(Math.floor((i - 25) / 3), 2),
                        ballSpeed: 1.2 + ((i - 20) * 0.03),
                        difficulty: 'medium',
                        specialMechanic: i % 8 === 0 ? 'rotating' : null
                    });
                }
                
                // Levels 41-60: Advanced (Hard)
                for (let i = 41; i <= 60; i++) {
                    configs.push({
                        funnelSize: 30,
                        obstacles: Math.min(4 + Math.floor((i - 40) / 2), 10),
                        timeLimit: 0,
                        movingObstacles: Math.min(Math.floor((i - 40) / 3), 4),
                        ballSpeed: 1.4 + ((i - 40) * 0.04),
                        difficulty: 'hard',
                        specialMechanic: ['rotating', 'bouncy'][Math.floor((i - 40) / 10) % 2]
                    });
                }
                
                // Levels 61-80: Expert
                for (let i = 61; i <= 80; i++) {
                    configs.push({
                        funnelSize: 30,
                        obstacles: Math.min(6 + Math.floor((i - 60) / 2), 15),
                        timeLimit: 0,
                        movingObstacles: Math.min(3 + Math.floor((i - 60) / 3), 6),
                        ballSpeed: 1.6 + ((i - 60) * 0.05),
                        difficulty: 'expert',
                        specialMechanic: ['maze', 'spiral'][Math.floor((i - 60) / 10) % 2]
                    });
                }
                
                // Levels 81-100: Legendary
                for (let i = 81; i <= 100; i++) {
                    configs.push({
                        funnelSize: 30,
                        obstacles: Math.min(10 + Math.floor((i - 80) / 2), 20),
                        timeLimit: 0,
                        movingObstacles: Math.min(4 + Math.floor((i - 80) / 2), 8),
                        ballSpeed: 1.8 + ((i - 80) * 0.06),
                        difficulty: 'legendary',
                        specialMechanic: ['ultimate', 'chaos'][Math.floor((i - 80) / 10) % 2]
                    });
                }
                
                // Levels 101-250: Keeping 30px minimum funnel, increasing obstacles
                for (let i = 101; i <= 250; i++) {
                    const tier = Math.floor((i - 101) / 50);
                    const difficultyNames = ['master', 'grandmaster', 'ultimate'];
                    
                    configs.push({
                        funnelSize: 30,
                        obstacles: Math.min(12 + Math.floor((i - 100) / 5), 35),
                        timeLimit: 0,
                        movingObstacles: Math.min(5 + Math.floor((i - 100) / 10), 15),
                        ballSpeed: 2.0 + ((i - 100) * 0.02),
                        difficulty: difficultyNames[Math.min(tier, 2)],
                        specialMechanic: ['master_challenge', 'ultimate_precision', 'chaos_mode'][tier % 3]
                    });
                }
                
                return configs;
            }
            setupLevel() {
                // NEW: Show level preview
                // this.showLevelPreview();
                
                // Clear any existing obstacles and particles
                this.clearObstacles();
                this.clearParticles();
                this.ballTrail = [];
                this.clearBallTrail();
                
                const config = this.getCurrentConfig();
                
                // Setup funnel with enforced minimum size
                const funnelSize = Math.max(config.funnelSize, 30);
                this.funnel.style.width = funnelSize + 'px';
                this.funnel.style.height = funnelSize + 'px';
                
                // Enhanced funnel positioning with fixed obstacle overlap bug
                const minDistanceFromBall = 120;
                const margin = Math.max(funnelSize + 20, 30);
                let attempts = 0;
                let validFunnelPosition = false;

                while (!validFunnelPosition && attempts < 50) {
                    this.funnelX = margin + Math.random() * (this.containerWidth - 2 * margin - funnelSize);
                    this.funnelY = margin + Math.random() * (this.containerHeight - 2 * margin - funnelSize);
                    
                    const funnelCenterX = this.funnelX + funnelSize / 2;
                    const funnelCenterY = this.funnelY + funnelSize / 2;
                    const distanceFromBall = Math.sqrt((funnelCenterX - 165) ** 2 + (funnelCenterY - 165) ** 2);
                    
                    if (distanceFromBall >= minDistanceFromBall) {
                        validFunnelPosition = true;
                    }
                    attempts++;
                }

                // Improved fallback positions
                if (!validFunnelPosition) {
                    const fallbackPositions = [
                        { x: this.containerWidth - funnelSize - 40, y: 40 },
                        { x: 40, y: this.containerHeight - funnelSize - 40 },
                        { x: this.containerWidth - funnelSize - 40, y: this.containerHeight - funnelSize - 40 },
                        { x: 40, y: 40 }
                    ];
                    
                    const randomFallback = fallbackPositions[Math.floor(Math.random() * fallbackPositions.length)];
                    this.funnelX = randomFallback.x;
                    this.funnelY = randomFallback.y;
                }
                
                this.funnel.style.left = this.funnelX + 'px';
                this.funnel.style.top = this.funnelY + 'px';
                
                // Add obstacles with special mechanics
                this.addObstacles(config.obstacles, config.movingObstacles, config.specialMechanic);
                
                // Reset ball to center
                this.ballX = 165;
                this.ballY = 165;
                this.ballVelX = 0;
                this.ballVelY = 0;
                
                // Reset level attempt tracking
                this.levelAttempts = 0;
                this.stuckTimer = 0;
                // this.emergencyCenter.classList.remove('show');
                document.getElementById('skipLevelHint').classList.remove('show');
                document.getElementById('skipButton').style.display = 'none';
                
                this.updateDifficultyBadge(config.difficulty);
            }
            
            showLevelPreview() {
                // NEW: Show level preview before starting
                if (!this.gameRunning) return;
                
                const config = this.getCurrentConfig();
                const preview = this.levelPreview;
                
                document.getElementById('previewLevel').textContent = this.level;
                document.getElementById('previewDifficulty').textContent = config.difficulty.toUpperCase();
                document.getElementById('previewObstacles').textContent = config.obstacles + config.movingObstacles;
                document.getElementById('previewFunnelSize').textContent = config.funnelSize + 'px';
                
                preview.classList.add('show');
                
                setTimeout(() => {
                    preview.classList.remove('show');
                }, 2000);
            }
            
            getCurrentConfig() {
                return this.levelConfigs[Math.min(this.level - 1, this.levelConfigs.length - 1)];
            }
            
            addObstacles(numStatic, numMoving, specialMechanic) {
                for (let i = 0; i < numStatic; i++) {
                    this.createObstacle(false, specialMechanic);
                }
                
                for (let i = 0; i < numMoving; i++) {
                    this.createObstacle(true, specialMechanic);
                }
            }
            
            createObstacle(isMoving = false, specialMechanic = null) {
                const obstacle = document.createElement('div');
                obstacle.className = 'obstacle';
                
                const size = 20 + Math.random() * 15;
                obstacle.style.width = size + 'px';
                obstacle.style.height = size + 'px';
                
                // FIXED: Enhanced positioning with proper collision detection
                let x, y;
                let attempts = 0;
                let validPosition = false;
                
                while (!validPosition && attempts < 100) {
                    const ballX = 165;
                    const ballY = 165;
                    const funnelCenterX = this.funnelX + this.getCurrentConfig().funnelSize / 2;
                    const funnelCenterY = this.funnelY + this.getCurrentConfig().funnelSize / 2;
                    
                    const pathProgress = Math.random();
                    const pathVariation = (Math.random() - 0.5) * 120;
                    
                    const directX = ballX + (funnelCenterX - ballX) * pathProgress;
                    const directY = ballY + (funnelCenterY - ballY) * pathProgress;
                    
                    const pathAngle = Math.atan2(funnelCenterY - ballY, funnelCenterX - ballX);
                    const perpAngle = pathAngle + Math.PI / 2;
                    
                    x = directX + Math.cos(perpAngle) * pathVariation;
                    y = directY + Math.sin(perpAngle) * pathVariation;
                    
                    x = Math.max(20, Math.min(x, this.containerWidth - size - 20));
                    y = Math.max(20, Math.min(y, this.containerHeight - size - 20));
                    
                    const distanceFromBall = Math.sqrt((x + size/2 - ballX) ** 2 + (y + size/2 - ballY) ** 2);
                    
                    // FIXED: Proper funnel collision detection using obstacle center and both radii
                    const distanceFromFunnel = Math.sqrt(
                        (x + size/2 - funnelCenterX) ** 2 + (y + size/2 - funnelCenterY) ** 2
                    ) - this.getCurrentConfig().funnelSize / 2 - size / 2;
                    
                    let tooCloseToOtherObstacles = false;
                    this.obstacles.forEach(otherObstacle => {
                        const otherRect = otherObstacle.element.getBoundingClientRect();
                        const containerRect = this.gameContainer.getBoundingClientRect();
                        const otherX = otherRect.left - containerRect.left;
                        const otherY = otherRect.top - containerRect.top;
                        
                        const distance = Math.sqrt((x + size/2 - otherX - otherObstacle.width/2) ** 2 + (y + size/2 - otherY - otherObstacle.height/2) ** 2);
                        if (distance < (size + otherObstacle.width) / 2 + 15) {
                            tooCloseToOtherObstacles = true;
                        }
                    });
                    
                    if (distanceFromBall >= 50 && 
    distanceFromFunnel >= 30 && 
    !tooCloseToOtherObstacles) {
    validPosition = true;
}
                    
                    attempts++;
                }
                
                if (!validPosition) {
                    const margin = 30;
                    x = margin + Math.random() * (this.containerWidth - 2 * margin - size);
                    y = margin + Math.random() * (this.containerHeight - 2 * margin - size);
                }
                
                obstacle.style.left = x + 'px';
                obstacle.style.top = y + 'px';
                
                this.gameContainer.appendChild(obstacle);
                this.obstacles.push({ element: obstacle, x, y, width: size, height: size, isMoving });
            }
            clearObstacles() {
                this.obstacles.forEach(obs => obs.element.remove());
                this.obstacles = [];
            }
            
            clearParticles() {
                this.particles.forEach(particle => particle.element.remove());
                this.particles = [];
            }
            
            clearBallTrail() {
                // NEW: Clear reusable trail elements
                this.ballTrailElements.forEach(element => element.remove());
                this.ballTrailElements = [];
            }
            
            updateDifficultyBadge(difficulty) {
                const badge = document.getElementById('difficultyBadge');
                badge.className = `difficulty-badge difficulty-${difficulty}`;
                badge.textContent = difficulty.toUpperCase();
            }
            
            updateUI() {
                document.getElementById('level').textContent = this.level;
                document.getElementById('score').textContent = this.score;
                document.getElementById('bestScore').textContent = this.bestScore;
                document.getElementById('achievementCount').textContent = this.achievements.length;
                
                const progress = Math.min((this.level / this.levelConfigs.length) * 100, 100);
                document.getElementById('progressLevel').textContent = Math.round(progress) + '%';
                document.getElementById('progressFill').style.width = progress + '%';
            }
            
            async requestPermission() {
                try {
                    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        if (permission === 'granted') {
                            this.startGame();
                        }
                    } else {
                        this.startGame();
                    }
                } catch (error) {
                    console.error('Permission request failed:', error);
                    this.startGame();
                }
            }
            
            startGame() {
                this.gameRunning = true;
                this.gamePaused = false;
                this.levelCompleting = false; // Reset flag
                this.startButton.style.display = 'none';
                document.getElementById('menuButtons').style.display = 'flex';
                
                // Add device orientation and keyboard controls
                window.addEventListener('deviceorientation', (e) => this.handleOrientation(e));
                window.addEventListener('keydown', (e) => this.handleKeyboard(e));
                
                this.gameLoop();
            }
            
            handleOrientation(event) {
                if (!this.gameRunning || this.gamePaused) return;
                
                const gamma = event.gamma || 0;
                const beta = event.beta || 0;
                
                const config = this.getCurrentConfig();
                const sensitivity = (this.settings.sensitivity / 100) * this.sensitivity * config.ballSpeed;
                
                this.ballVelX += gamma * sensitivity * 0.1;
                this.ballVelY += beta * sensitivity * 0.1;
                
                // NEW: Apply velocity cap
                this.ballVelX = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.ballVelX));
                this.ballVelY = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.ballVelY));
            }
            
            handleKeyboard(event) {
                if (!this.gameRunning || this.gamePaused) return;
                
                const config = this.getCurrentConfig();
                const force = (this.settings.sensitivity / 100) * 0.5 * config.ballSpeed;
                
                switch(event.key) {
                    case 'ArrowLeft': 
                        this.ballVelX -= force; 
                        this.ballVelX = Math.max(-this.maxVelocity, this.ballVelX);
                        break;
                    case 'ArrowRight': 
                        this.ballVelX += force; 
                        this.ballVelX = Math.min(this.maxVelocity, this.ballVelX);
                        break;
                    case 'ArrowUp': 
                        this.ballVelY -= force; 
                        this.ballVelY = Math.max(-this.maxVelocity, this.ballVelY);
                        break;
                    case 'ArrowDown': 
                        this.ballVelY += force; 
                        this.ballVelY = Math.min(this.maxVelocity, this.ballVelY);
                        break;
                    case ' ': 
                        event.preventDefault();
                        if (this.gamePaused) this.resumeGame();
                        else this.pauseGame();
                        break;
                }
            }
            gameLoop() {
                if (!this.gameRunning || this.gamePaused) {
                    if (this.gameRunning) {
                        requestAnimationFrame(() => this.gameLoop());
                    }
                    return;
                }
                
                // NEW: Track if ball is stuck and show emergency center
                const currentPosition = { x: this.ballX, y: this.ballY };
                const distanceMoved = Math.sqrt(
                    (currentPosition.x - this.lastBallPosition.x) ** 2 + 
                    (currentPosition.y - this.lastBallPosition.y) ** 2
                );
                
                if (distanceMoved < 0.5) {
                    this.stuckTimer++;
                    if (this.stuckTimer > 300) { // 5 seconds at 60fps
                        // this.emergencyCenter.classList.add('show');
                    }
                } else {
                    this.stuckTimer = 0;
                    // this.emergencyCenter.classList.remove('show');
                }
                
                this.lastBallPosition = { ...currentPosition };
                
                // Apply physics
                this.ballVelX *= this.friction;
                this.ballVelY *= this.friction;
                
                this.ballX += this.ballVelX;
                this.ballY += this.ballVelY;
                
                // Wall collisions with enhanced bounce and feedback
                let wallCollision = false;
                if (this.ballX <= 0) {
                    this.ballX = 0;
                    this.ballVelX *= -0.7;
                    this.createParticles(this.ballX, this.ballY, '#ff6b6b');
                    wallCollision = true;
                }
                if (this.ballX >= this.containerWidth - this.ballSize) {
                    this.ballX = this.containerWidth - this.ballSize;
                    this.ballVelX *= -0.7;
                    this.createParticles(this.ballX, this.ballY, '#ff6b6b');
                    wallCollision = true;
                }
                if (this.ballY <= 0) {
                    this.ballY = 0;
                    this.ballVelY *= -0.7;
                    this.createParticles(this.ballX, this.ballY, '#ff6b6b');
                    wallCollision = true;
                }
                if (this.ballY >= this.containerHeight - this.ballSize) {
                    this.ballY = this.containerHeight - this.ballSize;
                    this.ballVelY *= -0.7;
                    this.createParticles(this.ballX, this.ballY, '#ff6b6b');
                    wallCollision = true;
                }
                
                // NEW: Enhanced wall collision feedback
                if (wallCollision) {
                    this.gameContainer.classList.add('collision-wall');
                    setTimeout(() => this.gameContainer.classList.remove('collision-wall'), 300);
                    
                    // Haptic feedback
                    if (this.settings.haptic && navigator.vibrate) {
                        navigator.vibrate(50);
                    }
                }
                
                // Update ball trail if enabled
                if (this.settings.trail) {
                    this.updateBallTrailOptimized();
                }
                
                // Update ball position
                this.ball.style.left = this.ballX + 'px';
                this.ball.style.top = this.ballY + 'px';
                
                // Check obstacle collisions
                this.checkObstacleCollision();
                
                // Check funnel collision
                this.checkFunnelCollision();
                
                requestAnimationFrame(() => this.gameLoop());
            }
            
            checkObstacleCollision() {
                this.obstacles.forEach(obs => {
                    const rect = obs.element.getBoundingClientRect();
                    const containerRect = this.gameContainer.getBoundingClientRect();
                    
                    const obsX = rect.left - containerRect.left;
                    const obsY = rect.top - containerRect.top;
                    
                    if (this.ballX < obsX + obs.width &&
                        this.ballX + this.ballSize > obsX &&
                        this.ballY < obsY + obs.height &&
                        this.ballY + this.ballSize > obsY) {
                        
                        // Enhanced collision response
                        this.ballVelX *= -0.5;
                        this.ballVelY *= -0.5;
                        
                        // NEW: Different particle effects for different collision types
                        this.createParticles(this.ballX + this.ballSize/2, this.ballY + this.ballSize/2, '#d69e2e', 8);
                        
                        // Enhanced visual feedback
                        obs.element.classList.add('collision-obstacle');
                        setTimeout(() => obs.element.classList.remove('collision-obstacle'), 300);
                        
                        this.gameContainer.classList.add('shake');
                        setTimeout(() => this.gameContainer.classList.remove('shake'), 300);
                        
                        // NEW: Haptic feedback for obstacle collision
                        if (this.settings.haptic && navigator.vibrate) {
                            navigator.vibrate([30, 10, 30]);
                        }
                        
                        // Push ball away from obstacle center
                        const centerX = obsX + obs.width / 2;
                        const centerY = obsY + obs.height / 2;
                        const ballCenterX = this.ballX + this.ballSize / 2;
                        const ballCenterY = this.ballY + this.ballSize / 2;
                        
                        const dx = ballCenterX - centerX;
                        const dy = ballCenterY - centerY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 0) {
                            this.ballVelX += (dx / distance) * 2;
                            this.ballVelY += (dy / distance) * 2;
                            
                            // Apply velocity cap after collision
                            this.ballVelX = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.ballVelX));
                            this.ballVelY = Math.max(-this.maxVelocity, Math.min(this.maxVelocity, this.ballVelY));
                        }
                        
                        // Track collision for level attempt tracking
                        this.levelAttempts++;
                        this.checkSkipLevelAvailability();
                    }
                });
            }
            
            checkFunnelCollision() {
                if (this.levelCompleting) return;
                
                const config = this.getCurrentConfig();
                const funnelSize = Math.max(config.funnelSize, 30);
                const funnelCenterX = this.funnelX + funnelSize / 2;
                const funnelCenterY = this.funnelY + funnelSize / 2;
                const ballCenterX = this.ballX + this.ballSize / 2;
                const ballCenterY = this.ballY + this.ballSize / 2;
                
                const distance = Math.sqrt(
                    (ballCenterX - funnelCenterX) ** 2 + 
                    (ballCenterY - funnelCenterY) ** 2
                );
                
                if (distance < funnelSize / 2 - 5) {
                    this.levelComplete();
                }
            }
            
            checkSkipLevelAvailability() {
                // NEW: Show skip option after multiple attempts
                if (this.levelAttempts >= 10) {
                    document.getElementById('skipLevelHint').classList.add('show');
                    document.getElementById('skipButton').style.display = 'inline-block';
                }
            }
            
            skipLevel() {
                // NEW: Skip level functionality
                if (this.levelAttempts < 10) return;
                
                if (confirm('Skip this level? You won\'t get points for it.')) {
                    this.level++;
                    
                    if (this.level > this.levelConfigs.length) {
                        this.endGame();
                        return;
                    }
                    
                    this.saveGame();
                    this.updateUI();
                    this.setupLevel();
                    
                    // Show notification
                    this.showNotification('Level Skipped', 'No points awarded', 2000);
                }
            }
            levelComplete() {
                if (this.levelCompleting) return;
                this.levelCompleting = true;
                
                // Enhanced visual feedback
                this.gameContainer.classList.add('pulse');
                setTimeout(() => this.gameContainer.classList.remove('pulse'), 500);
                
                // Calculate score
                const levelBonus = this.level * 100;
                const timeBonus = 0;
                const totalBonus = levelBonus + timeBonus;
                
                this.score += totalBonus;
                
                // Update best score with error handling
                if (this.score > this.bestScore) {
                    this.bestScore = this.score;
                    try {
                        localStorage.setItem('tiltSphereBest', this.bestScore.toString());
                    } catch (error) {
                        console.warn('Failed to save best score:', error);
                    }
                }
                
                // NEW: Enhanced celebration particles
                this.createParticles(this.ballX + this.ballSize/2, this.ballY + this.ballSize/2, '#68d391', 20);
                this.createParticles(this.ballX + this.ballSize/2, this.ballY + this.ballSize/2, '#ffd700', 12);
                
                // NEW: Haptic feedback for level completion
                if (this.settings.haptic && navigator.vibrate) {
                    navigator.vibrate([100, 50, 100, 50, 200]);
                }
                
                // Check for achievements before advancing level
                this.checkAchievements();
                
                // Advance to next level
                this.level++;
                
                // Check if game complete
                if (this.level > this.levelConfigs.length) {
                    this.endGame();
                    return;
                }
                
                // Auto-save progress
this.saveGame();

// Update UI
this.updateUI();

// Animate ball into funnel, then setup next level
this.animateBallIntoFunnel(() => {
    this.setupLevel();
    this.levelCompleting = false;
});
            }
            endGame() {
                this.gameRunning = false;
                this.levelCompleting = false;
                
                // NEW: Enhanced game completion message
                const message = `🎉 Congratulations! 🎉\n\nYou completed all ${this.levelConfigs.length} levels!\n\nFinal Score: ${this.score}\nBest Score: ${this.bestScore}\n\nYou are a TiltSphere Master!`;
                alert(message);
                
                // Reset for replay
                this.level = 1;
                this.score = 0;
                this.startButton.style.display = 'block';
                this.startButton.textContent = 'PLAY AGAIN';
                document.getElementById('menuButtons').style.display = 'none';
                this.setupLevel();
                this.updateUI();
            }
            
            pauseGame(autoPause = false) {
                if (!this.gameRunning) return;
                
                this.gamePaused = true;
                
                // NEW: Enhanced pause overlay instead of alert
                this.pausedOverlay.classList.add('show');
                
                if (autoPause) {
                    this.pausedOverlay.querySelector('p').textContent = 'Game auto-paused - Click to resume';
                } else {
                    this.pausedOverlay.querySelector('p').textContent = 'Click anywhere to resume';
                }
            }
            
            resumeGame() {
                if (!this.gamePaused) return;
                
                this.gamePaused = false;
                this.pausedOverlay.classList.remove('show');
                
                // Reset ball velocity to prevent accumulated motion
                this.ballVelX = 0;
                this.ballVelY = 0;
                
                // Reset pause text
                this.pausedOverlay.querySelector('p').textContent = 'Click anywhere to resume';
            }
            
            resetProgress() {
                if (confirm('Are you sure you want to reset all progress? This cannot be undone.')) {
                    // Enhanced cleanup with error handling
                    try {
                        localStorage.removeItem('tiltSphereSave');
                        localStorage.removeItem('tiltSphereBest');
                        localStorage.removeItem('tiltSphereAchievements');
                        localStorage.removeItem('tiltSphereSettings');
                    } catch (error) {
                        console.warn('Failed to clear some save data:', error);
                    }
                    
                    this.level = 1;
                    this.score = 0;
                    this.bestScore = 0;
                    this.achievements = [];
                    this.levelAttempts = 0;
                    this.gameRunning = false;
                    this.levelCompleting = false;
                    
                    // Reset settings to defaults
                    this.settings = {
                        sound: true,
                        haptic: true,
                        trail: true,
                        sensitivity: 50,
                        autoPause: true
                    };
                    
                    this.startButton.style.display = 'block';
                    this.startButton.textContent = 'START GAME';
                    document.getElementById('menuButtons').style.display = 'none';
                    
                    // Hide skip elements
                    document.getElementById('skipLevelHint').classList.remove('show');
                    document.getElementById('skipButton').style.display = 'none';
                    // this.emergencyCenter.classList.remove('show');
                    
                    this.setupLevel();
                    this.updateUI();
                    
                    document.getElementById('saveStatus').textContent = 'Progress reset';
                }
            }
            createParticles(x, y, color, count = 8) {
                // NEW: Performance-aware particle creation
                const maxParticles = window.devicePixelRatio > 1 ? 30 : 50; // Fewer on high-DPI displays
                if (this.particles.length > maxParticles) return;
                
                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.background = color;
                    particle.style.left = x + 'px';
                    particle.style.top = y + 'px';
                    
                    const angle = (Math.PI * 2 * i) / count;
                    const velocity = 30 + Math.random() * 20;
                    const dx = Math.cos(angle) * velocity;
                    const dy = Math.sin(angle) * velocity;
                    
                    particle.style.setProperty('--dx', dx + 'px');
                    particle.style.setProperty('--dy', dy + 'px');
                    particle.classList.add('particle-explosion');
                    
                    this.gameContainer.appendChild(particle);
                    this.particles.push({ element: particle, life: 0.8 });
                    
                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.remove();
                        }
                        this.particles = this.particles.filter(p => p.element !== particle);
                    }, 800);
                }
            }
            
            updateBallTrailOptimized() {
                // NEW: Optimized trail system that reuses DOM elements
                this.ballTrail.push({
                    x: this.ballX + this.ballSize/2,
                    y: this.ballY + this.ballSize/2,
                    life: 1.0
                });
                
                // Keep trail short for performance
                if (this.ballTrail.length > 8) {
                    this.ballTrail.shift();
                }
                
                // Reuse existing trail elements instead of recreating
                while (this.ballTrailElements.length < this.ballTrail.length) {
                    const trail = document.createElement('div');
                    trail.className = 'ball-trail';
                    this.gameContainer.appendChild(trail);
                    this.ballTrailElements.push(trail);
                }
                
                // Hide excess elements
                for (let i = this.ballTrail.length; i < this.ballTrailElements.length; i++) {
                    this.ballTrailElements[i].style.display = 'none';
                }
                
                // Update visible trail elements
                this.ballTrail.forEach((point, index) => {
                    const trail = this.ballTrailElements[index];
                    if (trail) {
                        trail.style.display = 'block';
                        trail.style.left = (point.x - 7.5) + 'px';
                        trail.style.top = (point.y - 7.5) + 'px';
                        trail.style.opacity = (index / this.ballTrail.length) * 0.7;
                        trail.style.transform = `scale(${0.3 + (index / this.ballTrail.length) * 0.7})`;
                    }
                });
            }
            
            showNotification(title, description, duration = 3000) {
                // NEW: General notification system
                const notification = document.createElement('div');
                notification.className = 'achievement-notification';
                notification.innerHTML = `
                    <div class="achievement-title">${title}</div>
                    <div class="achievement-description">${description}</div>
                `;
                
                document.body.appendChild(notification);
                
                // Animate in
                setTimeout(() => notification.classList.add('show'), 100);
                
                // Animate out and remove
                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, 500);
                }, duration);
            }
            
            showAchievementNotification(achievementName) {
                // NEW: Achievement notification system
                const achievementData = this.getAchievementData(achievementName);
                if (!achievementData) return;
                
                const notification = this.achievementNotification;
                document.getElementById('achievementTitle').textContent = achievementData.title;
                document.getElementById('achievementDescription').textContent = achievementData.description;
                
                notification.classList.add('show');
                
                // Auto-hide after 4 seconds
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 4000);
                
                // Haptic feedback for achievement
                if (this.settings.haptic && navigator.vibrate) {
                    navigator.vibrate([200, 100, 200]);
                }
            }
            
            getAchievementData(achievementName) {
                // NEW: Achievement data mapping
                const achievements = {
                    'first_win': { title: '🎉 First Victory!', description: 'Completed your first level!' },
                    'level_10': { title: '🔟 Ten Levels Down!', description: 'Reached level 10' },
                    'level_25': { title: '🌟 Quarter Century!', description: 'Reached level 25' },
                    'level_50': { title: '⭐ Halfway There!', description: 'Reached level 50' },
                    'level_75': { title: '💫 Three Quarters!', description: 'Reached level 75' },
                    'level_100': { title: '💯 Century Mark!', description: 'Reached level 100' },
                    'level_125': { title: '🚀 Beyond Limits!', description: 'Reached level 125' },
                    'level_150': { title: '⚡ Lightning Fast!', description: 'Reached level 150' },
                    'level_175': { title: '🌈 Almost There!', description: 'Reached level 175' },
                    'level_200': { title: '🏆 Legendary Status!', description: 'Reached level 200' },
                    'level_225': { title: '👑 Royal Achievement!', description: 'Reached level 225' },
                    'level_250': { title: '🎯 Perfect Score!', description: 'Completed all levels!' },
                    'tier_easy': { title: '🟢 Easy Tier Complete!', description: 'Mastered the basics' },
                    'tier_medium': { title: '🟡 Medium Tier Complete!', description: 'Building skills' },
                    'tier_hard': { title: '🟠 Hard Tier Complete!', description: 'Getting challenging' },
                    'tier_expert': { title: '🔴 Expert Tier Complete!', description: 'Expert level achieved' },
                    'tier_legendary': { title: '🟣 Legendary Tier Complete!', description: 'Legendary skills' },
                    'tier_master': { title: '⚫ Master Tier Complete!', description: 'Master level reached' },
                    'tier_grandmaster': { title: '🔵 Grandmaster Tier Complete!', description: 'Grandmaster achieved' },
                    'tier_ultimate': { title: '⚪ Ultimate Tier Complete!', description: 'Ultimate mastery!' },
                    'score_5k': { title: '💰 5K Points!', description: 'Scored 5,000 points' },
                    'score_10k': { title: '💎 10K Points!', description: 'Scored 10,000 points' },
                    'score_25k': { title: '🏅 25K Points!', description: 'Scored 25,000 points' },
                    'score_50k': { title: '🥈 50K Points!', description: 'Scored 50,000 points' },
                    'score_100k': { title: '🥇 100K Points!', description: 'Scored 100,000 points' }
                };
                
                return achievements[achievementName];
            }
            saveGame() {
                const saveData = {
                    level: this.level,
                    score: this.score,
                    achievements: this.achievements,
                    timestamp: Date.now(),
                    version: '2.0' // NEW: Version tracking for future compatibility
                };
                
                try {
                    localStorage.setItem('tiltSphereSave', JSON.stringify(saveData));
                    
                    // Show save indicator
                    const indicator = document.getElementById('saveIndicator');
                    indicator.classList.add('show');
                    setTimeout(() => indicator.classList.remove('show'), 2000);
                    
                    document.getElementById('saveStatus').textContent = `Last saved: ${new Date().toLocaleTimeString()}`;
                } catch (error) {
                    console.warn('Failed to save game:', error);
                    document.getElementById('saveStatus').textContent = 'Save failed - storage full?';
                }
            }
            
            loadGame() {
                try {
                    const saveData = localStorage.getItem('tiltSphereSave');
                    if (saveData) {
                        const data = JSON.parse(saveData);
                        
                        // NEW: Version compatibility check
                        const version = data.version || '1.0';
                        
                        this.level = data.level || 1;
                        this.score = data.score || 0;
                        this.achievements = data.achievements || [];
                        
                        const saveTime = new Date(data.timestamp).toLocaleString();
                        document.getElementById('saveStatus').textContent = `Loaded save from: ${saveTime}`;
                        
                        // NEW: Migration for old saves
                        if (version === '1.0') {
                            this.migrateOldSave(data);
                        }
                    }
                } catch (error) {
                    console.warn('Failed to load save data:', error);
                    document.getElementById('saveStatus').textContent = 'Failed to load save data';
                }
            }
            
            migrateOldSave(data) {
                // NEW: Handle migration from older save formats
                console.log('Migrating save data from version 1.0 to 2.0');
                
                // Ensure achievements array exists
                if (!this.achievements) {
                    this.achievements = [];
                }
                
                // Auto-save migrated data
                this.saveGame();
            }
            
            checkAchievements() {
                // NEW: Enhanced achievement system with notifications
                const newAchievements = [];
                
                // First Win
                if (this.level === 2 && !this.achievements.includes('first_win')) {
                    newAchievements.push('first_win');
                    this.achievements.push('first_win');
                }
                
                // Level Milestones
                const milestones = [10, 25, 50, 75, 100, 125, 150, 175, 200, 225, 250];
                milestones.forEach(milestone => {
                    const achievementName = `level_${milestone}`;
                    if (this.level === milestone + 1 && !this.achievements.includes(achievementName)) {
                        newAchievements.push(achievementName);
                        this.achievements.push(achievementName);
                    }
                });
                
                // Tier Completion Achievements
                const tierCompletions = [
                    { level: 21, name: 'tier_easy' },
                    { level: 41, name: 'tier_medium' },
                    { level: 61, name: 'tier_hard' },
                    { level: 81, name: 'tier_expert' },
                    { level: 101, name: 'tier_legendary' },
                    { level: 151, name: 'tier_master' },
                    { level: 201, name: 'tier_grandmaster' },
                    { level: 251, name: 'tier_ultimate' }
                ];
                
                tierCompletions.forEach(tier => {
                    if (this.level === tier.level && !this.achievements.includes(tier.name)) {
                        newAchievements.push(tier.name);
                        this.achievements.push(tier.name);
                    }
                });
                
                // Score milestones
                const scoreAchievements = [
                    { score: 5000, name: 'score_5k' },
                    { score: 10000, name: 'score_10k' },
                    { score: 25000, name: 'score_25k' },
                    { score: 50000, name: 'score_50k' },
                    { score: 100000, name: 'score_100k' }
                ];
                
                scoreAchievements.forEach(achievement => {
                    if (this.score >= achievement.score && !this.achievements.includes(achievement.name)) {
                        newAchievements.push(achievement.name);
                        this.achievements.push(achievement.name);
                    }
                });
                
                // NEW: Show notifications for new achievements
                if (newAchievements.length > 0) {
                    try {
                        localStorage.setItem('tiltSphereAchievements', JSON.stringify(this.achievements));
                    } catch (error) {
                        console.warn('Failed to save achievements:', error);
                    }
                    
                    // Show first achievement immediately, queue others
                    this.showAchievementNotification(newAchievements[0]);
                    
                    // Queue additional achievements with delays
                    newAchievements.slice(1).forEach((achievement, index) => {
                        setTimeout(() => {
                            this.showAchievementNotification(achievement);
                        }, (index + 1) * 5000);
                    });
                }
            }
            showSettings() {
                // Update UI with current settings
                document.getElementById('sensitivitySlider').value = this.settings.sensitivity;
                document.getElementById('sensitivityValue').textContent = this.settings.sensitivity;
                document.getElementById('soundToggle').checked = this.settings.sound;
                document.getElementById('hapticToggle').checked = this.settings.haptic;
                document.getElementById('trailToggle').checked = this.settings.trail;
                document.getElementById('autoPauseToggle').checked = this.settings.autoPause;
                
                // Add slider event listener
                const slider = document.getElementById('sensitivitySlider');
                slider.oninput = () => {
                    document.getElementById('sensitivityValue').textContent = slider.value;
                };
                
                document.getElementById('settingsModal').style.display = 'flex';
            }
            
            closeSettings() {
                document.getElementById('settingsModal').style.display = 'none';
            }
            
            saveSettings() {
                // Get values from UI
                this.settings.sensitivity = parseInt(document.getElementById('sensitivitySlider').value);
                this.settings.sound = document.getElementById('soundToggle').checked;
                this.settings.haptic = document.getElementById('hapticToggle').checked;
                this.settings.trail = document.getElementById('trailToggle').checked;
                this.settings.autoPause = document.getElementById('autoPauseToggle').checked;
                
                // Save to localStorage with error handling
                try {
                    localStorage.setItem('tiltSphereSettings', JSON.stringify(this.settings));
                    
                    // Close modal
                    this.closeSettings();
                    
                    // Show confirmation
                    document.getElementById('saveStatus').textContent = 'Settings saved!';
                    setTimeout(() => {
                        const currentStatus = document.getElementById('saveStatus').textContent;
                        if (currentStatus.includes('Settings saved!')) {
                            document.getElementById('saveStatus').textContent = currentStatus.replace('Settings saved!', '').trim();
                        }
                    }, 3000);
                } catch (error) {
                    console.warn('Failed to save settings:', error);
                    alert('Failed to save settings. Storage may be full.');
                }
            }
        }
        
        // Initialize the game when page loads
        let game;
        
        // NEW: Better initialization with error handling
        document.addEventListener('DOMContentLoaded', () => {
            try {
                game = new TiltBallGame();
            } catch (error) {
                console.error('Failed to initialize game:', error);
                
                // Fallback error display
                document.body.innerHTML = `
                    <div style="color: white; text-align: center; padding: 50px;">
                        <h2>Game Failed to Load</h2>
                        <p>Please refresh the page to try again.</p>
                        <p style="font-size: 12px; margin-top: 20px;">Error: ${error.message}</p>
                    </div>
                `;
            }
        });
        
        // NEW: Handle orientation lock detection
        screen.orientation?.addEventListener('change', () => {
            if (game && game.gameRunning && !game.gamePaused) {
                // Brief pause to let user readjust
                game.ballVelX = 0;
                game.ballVelY = 0;
            }
        });
        
        // NEW: Handle visibility change for better auto-pause
        document.addEventListener('visibilitychange', () => {
            if (game && game.gameRunning && !game.gamePaused && game.settings.autoPause) {
                if (document.hidden) {
                    game.pauseGame(true);
                }
            }
        });
    </script>
</body>
</html>
